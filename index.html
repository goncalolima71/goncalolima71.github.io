<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8">
  <title>Jogo de F1 3D</title>
  <script>
    const isLocal = window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost";
    const base = document.createElement("base");
    base.href = isLocal ? "/" : "/goncalolima71.github.io/";
    document.head.appendChild(base);
  </script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #start-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #car-selection {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
    }
    .car-option {
      border: 3px solid transparent;
      border-radius: 10px;
      background: #333;
      padding: 10px;
      cursor: pointer;
      transition: border 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .car-option.selected {
      border: 3px solid #007bff;
      background: #222;
    }
    .car-thumb {
      width: 100px;
      height: 60px;
      object-fit: contain;
      margin-bottom: 10px;
      background: #111;
      border-radius: 5px;
    }
    #start-btn {
      padding: 20px 40px;
      font-size: 2rem;
      border: none;
      border-radius: 10px;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      margin-top: 30px;
      transition: background 0.2s;
    }
    #start-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }
    #loading-circle {
      width: 60px;
      height: 60px;
      border: 8px solid #eee;
      border-top: 8px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
      display: none;
    }
    @keyframes spin {
      0% { transform: rotate(0deg);}
      100% { transform: rotate(360deg);}
    }
    #lap-times {
      position: absolute; top: 10px; left: 10px;
      color: rgb(239, 239, 239); font-size: 20px;
      background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px;
      z-index: 1;
      display: none;
    }
    .track-option {
      border: 2px solid transparent;
      border-radius: 8px;
      background: #444;
      color: #fff;
      padding: 10px 24px;
      cursor: pointer;
      font-size: 1.1rem;
      transition: border 0.2s, background 0.2s;
      margin-bottom: 0;
    }
    .track-option.selected {
      border: 2px solid #ffb300;
      background: #222;
      color: #ffb300;
    }
    #customize-btn {
      margin: 20px 0 0 0;
      padding: 18px 36px;
      font-size: 1.5rem;
      border: none;
      border-radius: 10px;
      background: #ffb300;
      color: #222;
      cursor: pointer;
      transition: background 0.2s;
    }
    #customize-btn:hover {
      background: #ffd700;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <!-- Menu inicial -->
  <div id="start-screen">
    <h1 style="color:#fff; margin-bottom:30px;">Jogo de F1 3D</h1>
    <button id="customize-btn">Personalizar Carro</button>
    <div id="car-selection">
      <div class="car-option selected" data-model="aston_martin_f1_amr23_2023.glb">
        <span>Aston Martin AMR23</span>
      </div>
      <div class="car-option" data-model="scuderia_ferrari_f1_sf23_2023.glb">
        <span>Ferrari SF23</span>
      </div>
      <div class="car-option" data-model="mclaren_mcl60_f1_2023.glb">
        <span>McLaren MCL60</span>
      </div>
      <div class="car-option" data-model="mclaren_mp45__formula_1.glb">
        <span>McLaren MP4/5</span>
      </div>
      <div class="car-option" data-model="shrek_hip_hop_dance.glb">
        <span>Shrek</span>
      </div>
    </div>
    <div id="track-selection" style="display:flex; gap:20px; margin-bottom:20px;">
      <div class="track-option selected" data-track="default">Pista Original</div>
      <div class="track-option" data-track="monaco">Mónaco</div>
    </div>
    <div id="loading-circle"></div>
    <button id="start-btn">Start</button>
  </div>
  <div id="lap-times">
    Tempo da volta:
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { TextureLoader } from 'three';

    // Variáveis globais
    let scene, camera, renderer, carModel;
    let moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
    let currentSpeed = 0;
    const maxSpeed = 1.0;
    const acceleration = 0.02;
    const braking = 0.02;
    const turnSpeed = 0.01;
    let carDirection = 0;
    let curve;
    let reverse = false;
    let planeWidth = 28;
    let planeWidth2 = 20;
    let thirdPersonView = true;
    let frontView = false;
    let firstPersonView = false;
    let lapStartTime = 0;
    let lapTimes = [];
    let currentLap = 0;
    let passedStartLine = false;
    let startLinePosition;
    let lights = [];
    let shrekMixer = null; // Para animação do Shrek
    const clock = new THREE.Clock();
    let monacoStartLinePosition = null;

    // Elementos da UI
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    const loadingCircle = document.getElementById('loading-circle');
    const lapTimesDiv = document.getElementById('lap-times');
    const carOptions = document.querySelectorAll('.car-option');
    // --- Seleção de pista ---
    const trackOptions = document.querySelectorAll('.track-option');
    let selectedTrack = 'default';
    trackOptions.forEach(option => {
      option.addEventListener('click', () => {
        trackOptions.forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedTrack = option.dataset.track;
      });
    });

    // Estado inicial
    loadingCircle.style.display = 'none';
    startBtn.disabled = false;

    // Seleção de carro
    let selectedModel = carOptions[0].dataset.model;
    carOptions.forEach(option => {
      option.addEventListener('click', () => {
        carOptions.forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedModel = option.dataset.model;
      });
    });

    // Ao clicar em Start, carrega o modelo escolhido
    startBtn.addEventListener('click', () => {
      startBtn.disabled = true;
      loadingCircle.style.display = 'block';

      const loader = new GLTFLoader();
      const modelPath = isLocal
        ? `./${selectedModel}`
        : `/goncalolima71.github.io/${selectedModel}`;

      loader.load(
        modelPath,
        (gltf) => {
          loadingCircle.style.display = 'none';
          startScreen.style.display = 'none';
          lapTimesDiv.style.display = 'block';

          // Ajuste da escala e rotação conforme o modelo selecionado
          const carModelLoaded = gltf.scene;
          shrekMixer = null; // Limpa mixer anterior

          switch (selectedModel) {
            case "aston_martin_f1_amr23_2023.glb":
              carModelLoaded.scale.set(1.0, 1.0, 1.0);
              carModelLoaded.rotation.y = Math.PI;
              break;
            case "scuderia_ferrari_f1_sf23_2023.glb":
              carModelLoaded.scale.set(0.8, 0.8, 0.8);
              carModelLoaded.rotation.y = Math.PI;
              break;
            case "mclaren_mcl60_f1_2023.glb":
              carModelLoaded.scale.set(1.0, 1.0, 1.0);
              carModelLoaded.rotation.y = Math.PI;
              break;
            case "mclaren_mp45__formula_1.glb":
              carModelLoaded.scale.set(0.5, 0.5, 0.5);
              break;
            case "shrek_hip_hop_dance.glb":
              carModelLoaded.scale.set(0.7, 0.7, 0.7); // Shrek menor
              carModelLoaded.rotation.y = Math.PI;
              // Ativar animação de caminhada se existir
              if (gltf.animations && gltf.animations.length > 0) {
                shrekMixer = new THREE.AnimationMixer(carModelLoaded);
                const action = shrekMixer.clipAction(gltf.animations[0]);
                action.play();
                action.timeScale = 1.5; // Shrek anda mais rápido
              }
              break;
            default:
              carModelLoaded.scale.set(1.2, 1.2, 1.2);
          }

          // Escolher pista
          if (selectedTrack === 'monaco') {
            initMonaco(carModelLoaded);
          } else {
            init(carModelLoaded);
          }
          animate();
        },
        undefined,
        (error) => {
          loadingCircle.style.display = 'none';
          startBtn.innerText = "Erro ao carregar modelo!";
          startBtn.disabled = true;
          console.error('Erro ao carregar o modelo:', error);
        }
      );
    });

    function init(loadedCarModel) {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Já é suave, mas pode ser melhorado
      renderer.shadowMap.autoUpdate = true;
      renderer.shadowMap.needsUpdate = true;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x87CEEB);

      // Luz do sol (DirectionalLight) para simular o sol
      const sun = new THREE.DirectionalLight(0xfff7e0, 2.2); // cor amarelada, intensidade forte
      sun.position.set(80, 120, 60); // posição alta e lateral
      sun.castShadow = true;
      sun.shadow.mapSize.width = 4096; // aumentar resolução
      sun.shadow.mapSize.height = 4096;
      sun.shadow.bias = -0.0005; // reduzir artefactos
      sun.shadow.normalBias = 0.01;
      sun.shadow.radius = 4; // suavizar ainda mais
      sun.shadow.camera.near = 10;
      sun.shadow.camera.far = 400;
      sun.shadow.camera.left = -200;
      sun.shadow.camera.right = 200;
      sun.shadow.camera.top = 200;
      sun.shadow.camera.bottom = -200;
      scene.add(sun);
      // Opcional: helper para visualizar área de sombra
      // const helper = new THREE.CameraHelper(sun.shadow.camera);
      // scene.add(helper);

      // Luz direcional extra para iluminar melhor o carro (mantém, mas reduz intensidade)
      const light = new THREE.DirectionalLight(0xffffff, 0.7);
      light.position.set(0, 20, 20);
      light.castShadow = false;
      scene.add(light);

      createTrack();

      // Criar semáforo e guardar as luzes
      lights = createSemaphore();
      createStartingGrid();
      createFinishLine();

      const startPoint = curve.getPoint(0);
      const startTangent = curve.getTangent(0);

      carModel = loadedCarModel;
      carModel.position.copy(startPoint);
      carDirection = Math.atan2(startTangent.x, startTangent.z);
      carModel.rotation.y += carDirection;

      // Ajustar a altura do carro para ficar colado à pista (plano)
      // O valor é sempre atualizado na animação, então remova o offset extra!
      carModel.position.y = 0; // garantir que começa a 0
      carModel.lastY = 0; // garantir que a animação não soma offset
      carModel.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      scene.add(carModel);
      
      //adicionar relva simples (sem textura)
      const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x3a9c2d });
      const grassGeometry = new THREE.PlaneGeometry(2000, 2000);
      const grass = new THREE.Mesh(grassGeometry, grassMaterial);
      grass.rotation.x = -Math.PI / 2;
      grass.position.y = -0.02;
      scene.add(grass);


      // Função para verificar se um ponto está dentro dos limites da pista
      function isPointNearTrack(x, z, minDist = planeWidth / 2 + 8) {
        if (!curve) return false;
        let closestDist = Infinity;
        const divisions = 500;
        for (let i = 0; i <= divisions; i++) {
          const t = i / divisions;
          const point = curve.getPoint(t);
          const dx = point.x - x;
          const dz = point.z - z;
          const distSq = dx * dx + dz * dz;
          if (distSq < closestDist) closestDist = distSq;
        }
        return Math.sqrt(closestDist) < minDist;
      }

      // Função para adicionar árvores maiores e variadas
      function addTree(x, z, type = 0) {
        let trunk, crown;
        if (type === 0) {
          // Árvore redonda grande
          trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.5, 5),
            new THREE.MeshStandardMaterial({ color: 0x8b5a2b })
          );
          trunk.position.set(x, 2.5, z);
          trunk.castShadow = true;
          trunk.receiveShadow = true;

          crown = new THREE.Mesh(
            new THREE.SphereGeometry(2.2, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x267f00 })
          );
          crown.position.set(x, 6, z);
          crown.castShadow = true;
          crown.receiveShadow = true;
        } else {
          // Árvore tipo pinheiro grande
          trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 4),
            new THREE.MeshStandardMaterial({ color: 0x6b4226 })
          );
          trunk.position.set(x, 2, z);
          trunk.castShadow = true;
          trunk.receiveShadow = true;

          crown = new THREE.Mesh(
            new THREE.ConeGeometry(2, 4, 12),
            new THREE.MeshStandardMaterial({ color: 0x1b5e20 })
          );
          crown.position.set(x, 5, z);
          crown.castShadow = true;
          crown.receiveShadow = true;
        }
        scene.add(trunk);
        scene.add(crown);
      }

      // Adicionar muitas árvores maiores e mais juntas à volta da pista, evitando a pista
      let treesPlaced = 0;
      let tries = 0;
      const totalTrees = 180;
      while (treesPlaced < totalTrees && tries < totalTrees * 8) {
        tries++;
        const angle = Math.random() * Math.PI * 2;
        const radius = 120 + Math.random() * 80; // Mais perto da pista
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        if (!isPointNearTrack(x, z, planeWidth / 2 + 7)) { // margem menor para ficarem mais juntas
          const type = Math.random() > 0.5 ? 1 : 0;
          addTree(x, z, type);
          treesPlaced++;
        }
      }

      // Função para adicionar bancadas abertas e viradas para a pista, junto às bordas
      function addGrandstandFacingTrack(t, dist, width = 28, depth = 6, height = 4, color = 0xcccccc) {
        // t: valor entre 0 e 1 ao longo da curva
        const point = curve.getPointAt(t);
        const tangent = curve.getTangentAt(t);
        const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

        // Posição da bancada fora da pista
        const pos = new THREE.Vector3().copy(point).addScaledVector(perpendicular, dist);

        // Base da bancada
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(width, 0.5, depth),
          new THREE.MeshStandardMaterial({ color })
        );
        base.position.copy(pos);
        base.position.y += 0.25;
        base.castShadow = true;
        base.receiveShadow = true;

        // Costas da bancada (atrás) - agora do lado oposto ao público
        const back = new THREE.Mesh(
          new THREE.BoxGeometry(width, height, 0.3),
          new THREE.MeshStandardMaterial({ color: 0x888888 })
        );
        back.position.copy(pos);
        back.position.y += height / 2;
        back.position.x += perpendicular.x * (depth / 2 - 0.15);
        back.position.z += perpendicular.z * (depth / 2 - 0.15);
        back.castShadow = true;
        back.receiveShadow = true;

        // Orientar ambos para a pista (para o ponto da pista mais próximo)
        base.lookAt(point.x, base.position.y, point.z);
        back.lookAt(point.x, back.position.y, point.z);

        scene.add(base);
        scene.add(back);

        // Público em filas, alinhado com a bancada e virado para a pista
        for (let i = 0; i < width - 2; i += 2) {
          for (let j = 0; j < 3; j++) {
            const fan = new THREE.Mesh(
              new THREE.SphereGeometry(0.5, 8, 8),
              new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
            );
            // Distribuir os adeptos em filas, alinhados com a base da bancada
            const offsetDepth = depth / 2 - 1.2 - j * 1.2; // Fica do lado aberto
            fan.position.set(
              base.position.x + perpendicular.x * offsetDepth + tangent.x * (i - width / 2 + 2),
              base.position.y + 0.8,
              base.position.z + perpendicular.z * offsetDepth + tangent.z * (i - width / 2 + 2)
            );
            fan.lookAt(point.x, fan.position.y, point.z);
            fan.castShadow = true;
            fan.receiveShadow = true;
            scene.add(fan);
          }
        }
      }

      // Colocar bancadas junto às bordas da pista e viradas para a pista
      addGrandstandFacingTrack(0.08, planeWidth / 2 + 8, 28, 6, 4, 0xcccccc);
      addGrandstandFacingTrack(0.32, -(planeWidth / 2 + 8), 22, 6, 4, 0x888888);
      addGrandstandFacingTrack(0.62, planeWidth / 2 + 8, 24, 6, 4, 0xbbbbbb);

      startRaceCountdown();
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', (e) => {
        if (e.key === 'a' || e.key === 'ArrowLeft') moveLeft = true;
        if (e.key === 'd' || e.key === 'ArrowRight') moveRight = true;
        if (e.key === 'w' || e.key === 'ArrowUp') moveUp = true;
        if (e.key === 's' || e.key === 'ArrowDown') moveDown = true;
        if (e.key === 'r') reverse = true;
        if (e.key === 'p') {
          firstPersonView = !firstPersonView;
          thirdPersonView = !firstPersonView;
        }
        if (e.key === 'b') {
          frontView = true;
        }
      });
      document.addEventListener('keyup', (e) => {
        if (e.key === 'a' || e.key === 'ArrowLeft') moveLeft = false;
        if (e.key === 'd' || e.key === 'ArrowRight') moveRight = false;
        if (e.key === 'w' || e.key === 'ArrowUp') moveUp = false;
        if (e.key === 's' || e.key === 'ArrowDown') moveDown = false;
        if (e.key === 'r') reverse = false;
        if (e.key === 'b') frontView = false;
      });
    }

    // Função para criar a pista de Mónaco
    function initMonaco(loadedCarModel) {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x7ec0ee); // azul claro, céu

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x7ec0ee);

      // Sol
      const sun = new THREE.DirectionalLight(0xfff7e0, 2.2);
      sun.position.set(80, 120, 60);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 4096;
      sun.shadow.mapSize.height = 4096;
      sun.shadow.bias = -0.0005;
      sun.shadow.normalBias = 0.01;
      sun.shadow.radius = 4;
      sun.shadow.camera.near = 10;
      sun.shadow.camera.far = 400;
      sun.shadow.camera.left = -200;
      sun.shadow.camera.right = 200;
      sun.shadow.camera.top = 200;
      sun.shadow.camera.bottom = -200;
      scene.add(sun);

      // Luz ambiente
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));

      // Luz extra
      const light = new THREE.DirectionalLight(0xffffff, 0.7);
      light.position.set(0, 20, 20);
      light.castShadow = false;
      scene.add(light);

      // --- Traçado da pista de Mónaco (mais comprida, mais subidas e descidas) ---
      const points = [
        new THREE.Vector3(350, 0, 0),
        new THREE.Vector3(300, 2, 40),
        new THREE.Vector3(250, 6, 80),
        new THREE.Vector3(200, 12, 120), // subida longa
        new THREE.Vector3(150, 16, 160),
        new THREE.Vector3(100, 18, 200), // ponto mais alto
        new THREE.Vector3(50, 14, 220),
        new THREE.Vector3(0, 8, 210), // descida
        new THREE.Vector3(-40, 2, 180),
        new THREE.Vector3(-80, -2, 140), // descida acentuada
        new THREE.Vector3(-120, -6, 100),
        new THREE.Vector3(-160, -8, 60), // ponto mais baixo
        new THREE.Vector3(-180, -6, 20),
        new THREE.Vector3(-200, -2, -30), // subida
        new THREE.Vector3(-180, 2, -70),
        new THREE.Vector3(-140, 8, -110),
        new THREE.Vector3(-100, 14, -150), // subida longa
        new THREE.Vector3(-60, 18, -170), // ponto alto
        new THREE.Vector3(-20, 16, -180),
        new THREE.Vector3(20, 12, -200), // descida
        new THREE.Vector3(60, 8, -220),
        new THREE.Vector3(120, 4, -240),
        new THREE.Vector3(200, 0, -260), // volta ao nível inicial
        new THREE.Vector3(300, 0, -260),
        new THREE.Vector3(470, 0, -220),
        new THREE.Vector3(470, 0, 0),
        new THREE.Vector3(350, 0, 0)
      ];
      curve = new THREE.CatmullRomCurve3(points, true);

      // Calcular centro aproximado do circuito para uso global na marina
      let sumX = 0, sumZ = 0;
      for (let i = 0; i < points.length; i++) {
        sumX += points[i].x;
        sumZ += points[i].z;
      }
      const centerX = sumX / points.length;
      const centerZ = sumZ / points.length;

      // Pista
      const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const divisions = 500;
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];
      // Novo: lista para guardar "pedras" das subidas/descidas
      const stoneSegments = [];
      for (let i = 0; i < divisions; i++) {
        const t1 = i / divisions;
        const t2 = (i + 1) / divisions;
        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);
        const tangent1 = curve.getTangent(t1);
        const tangent2 = curve.getTangent(t2);
        const normal1 = new THREE.Vector3(-tangent1.z, 0, tangent1.x).normalize();
        const normal2 = new THREE.Vector3(-tangent2.z, 0, tangent2.x).normalize();
        const left1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, -planeWidth / 2);
        const right1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, planeWidth / 2);
        const left2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, -planeWidth / 2);
        const right2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, planeWidth / 2);
        const baseIndex = vertices.length / 3;
        vertices.push(
          left1.x, left1.y, left1.z,
          right1.x, right1.y, right1.z,
          left2.x, left2.y, left2.z,
          right2.x, right2.y, right2.z
        );
        indices.push(
          baseIndex, baseIndex + 1, baseIndex + 2,
          baseIndex + 1, baseIndex + 3, baseIndex + 2
        );
        // Adicionar "pedra" por baixo das subidas/descidas (y > 0)
        if (p1.y > 0 || p2.y > 0) {
          // Baixar as pedras para garantir que ficam bem abaixo da pista
          const minY = Math.min(p1.y, p2.y);
          if (minY > 0) {
            const stoneYOffset = -2.5; // valor mais negativo para garantir separação clara
            // Calcular as 4 bordas do segmento da pista para o solo
            const leftA = new THREE.Vector3().copy(p1).addScaledVector(normal1, -planeWidth / 2);
            const rightA = new THREE.Vector3().copy(p1).addScaledVector(normal1, planeWidth / 2);
            const leftB = new THREE.Vector3().copy(p2).addScaledVector(normal2, -planeWidth / 2);
            const rightB = new THREE.Vector3().copy(p2).addScaledVector(normal2, planeWidth / 2);
            leftA.y = stoneYOffset;
            rightA.y = stoneYOffset;
            leftB.y = stoneYOffset;
            rightB.y = stoneYOffset;
            // Calcular as 4 bordas do segmento da pista para a parte inferior da pista
            const leftAUp = new THREE.Vector3().copy(p1).addScaledVector(normal1, -planeWidth / 2); leftAUp.y -= 0.1;
            const rightAUp = new THREE.Vector3().copy(p1).addScaledVector(normal1, planeWidth / 2); rightAUp.y -= 0.1;
            const leftBUp = new THREE.Vector3().copy(p2).addScaledVector(normal2, -planeWidth / 2); leftBUp.y -= 0.1;
            const rightBUp = new THREE.Vector3().copy(p2).addScaledVector(normal2, planeWidth / 2); rightBUp.y -= 0.1;
            // 2 triângulos para formar um retângulo entre o solo e a parte inferior da pista
            const stoneGeometry = new THREE.BufferGeometry();
            const stoneVertices = new Float32Array([
              leftA.x, leftA.y, leftA.z,
              rightA.x, rightA.y, rightA.z,
              leftB.x, leftB.y, leftB.z,
              rightB.x, rightB.y, rightB.z,
              leftAUp.x, leftAUp.y, leftAUp.z,
              rightAUp.x, rightAUp.y, rightAUp.z,
              leftBUp.x, leftBUp.y, leftBUp.z,
              rightBUp.x, rightBUp.y, rightBUp.z
            ]);
            const stoneIndices = [
              0, 1, 4, 1, 5, 4,
              1, 3, 5, 3, 7, 5,
              3, 2, 7, 2, 6, 7,
              2, 0, 6, 0, 4, 6,
              4, 5, 6, 5, 7, 6
            ];
            stoneGeometry.setAttribute('position', new THREE.BufferAttribute(stoneVertices, 3));
            stoneGeometry.setIndex(stoneIndices);
            stoneGeometry.computeVertexNormals();
            const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8 });
            const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
            stone.castShadow = true;
            stone.receiveShadow = true;
            scene.add(stone);
          }
        }
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      const track = new THREE.Mesh(geometry, trackMaterial);
      track.receiveShadow = true;
      track.castShadow = true;
      scene.add(track);

      // Carregar texturas
      const textureLoader = new THREE.TextureLoader();
      const waterTexture = textureLoader.load('/textures/material_604.png');
      waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
      //waterTexture.repeat.set(4, 4); // Menos repetições

      const metalTexture = textureLoader.load('/textures/Metal052C.png'); // Caminho para a textura de metal
      metalTexture.wrapS = metalTexture.wrapT = THREE.RepeatWrapping;
      metalTexture.repeat.set(2, 2);

      // --- MARINA: água só fora do limite exterior da pista, sem elementos no interior ---
      const seaMaterial = new THREE.MeshStandardMaterial({
        map: waterTexture,
        color: 0x184060, // azul escuro e discreto
        transparent: true,
        opacity: 0.85 // menos vivacidade
      });
      window.seaMaterial = seaMaterial; // tornar global para acesso posterior
      window.waterTexture = waterTexture; // tornar global para acesso posterior

      const seaGeometry = new THREE.PlaneGeometry(6000, 6000);
      const sea = new THREE.Mesh(seaGeometry, seaMaterial);
      sea.rotation.x = -Math.PI / 2;
      sea.position.y = -8.2; // ligeiramente abaixo da pista
      sea.receiveShadow = true;
      scene.add(sea);
      // Grid, semáforo, etc (igual à pista original)
      lights = createSemaphore();
      createStartingGrid();
      createFinishLine();

      //posiçao de partida
      const tStart = 0.025;

      // Carro
      const startPoint = curve.getPoint(0);
      const startTangent = curve.getTangentAt(tStart);
      carModel = loadedCarModel;
      carModel.position.copy(startPoint);
      carDirection = Math.atan2(startTangent.x, startTangent.z);
      carModel.rotation.y += carDirection;
      carModel.position.y = 0;
      carModel.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      scene.add(carModel);

      // Adicionar túnel curvo entre (-100,0,20) e (-200,0,-30) seguindo a pista (ajustar altura do túnel à pista)
      function addCurvedTunnel() {
        let t1 = 0, t2 = 0;
        let minDist1 = Infinity, minDist2 = Infinity;
        for (let i = 0; i <= 1000; i++) {
          const t = i / 1000;
          const p = curve.getPointAt(t);
          const d1 = p.distanceTo(new THREE.Vector3(-100, 0, 20));
          const d2 = p.distanceTo(new THREE.Vector3(-200, 0, -30));
          if (d1 < minDist1) { minDist1 = d1; t1 = t; }
          if (d2 < minDist2) { minDist2 = d2; t2 = t; }
        }
        if (t2 < t1) [t1, t2] = [t2, t1];
        const segments = 32;
        const tunnelHeight = 10;
        const tunnelWidth = planeWidth;
        const wallThickness = 1.2;
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.2, roughness: 0.7 });
        for (let i = 0; i < segments; i++) {
          const tA = t1 + (t2 - t1) * (i / segments);
          const tB = t1 + (t2 - t1) * ((i + 1) / segments);
          const pA = curve.getPointAt(tA);
          const pB = curve.getPointAt(tB);
          const mid = new THREE.Vector3().addVectors(pA, pB).multiplyScalar(0.5);
          const dir = new THREE.Vector3().subVectors(pB, pA).normalize();
          const perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize();
          const roofLength = pA.distanceTo(pB);
          // Altura média do segmento
          const yA = pA.y, yB = pB.y;
          // Teto curvo: segue a média da altura dos pontos da pista
          const roof = new THREE.Mesh(
            new THREE.BoxGeometry(roofLength, wallThickness, tunnelWidth),
            wallMaterial
          );
          roof.position.copy(mid);
          roof.position.y = (yA + yB) / 2 + tunnelHeight - wallThickness / 2;
          const tunnelAxis = new THREE.Vector3(1, 0, 0);
          const quaternion = new THREE.Quaternion().setFromUnitVectors(tunnelAxis, dir);
          roof.setRotationFromQuaternion(quaternion);
          roof.castShadow = true;
          roof.receiveShadow = true;
          scene.add(roof);
          // Parede esquerda curva
          const leftWall = new THREE.Mesh(
            new THREE.BoxGeometry(roofLength, tunnelHeight, wallThickness),
            wallMaterial
          );
          leftWall.position.copy(mid);
          leftWall.position.y = (yA + yB) / 2 + tunnelHeight / 2;
          leftWall.position.addScaledVector(perp, -tunnelWidth / 2 + wallThickness / 2);
          leftWall.setRotationFromQuaternion(quaternion);
          leftWall.castShadow = true;
          leftWall.receiveShadow = true;
          scene.add(leftWall);
          // Parede direita curva
          const rightWall = new THREE.Mesh(
            new THREE.BoxGeometry(roofLength, tunnelHeight, wallThickness),
            wallMaterial
          );
          rightWall.position.copy(mid);
          rightWall.position.y = (yA + yB) / 2 + tunnelHeight / 2;
          rightWall.position.addScaledVector(perp, tunnelWidth / 2 - wallThickness / 2);
          rightWall.setRotationFromQuaternion(quaternion);
          rightWall.castShadow = true;
          rightWall.receiveShadow = true;
          scene.add(rightWall);
          // Luzes no teto
          const lightPos = new THREE.Vector3().copy(mid);
          lightPos.y = (yA + yB) / 2 + tunnelHeight - 1.5;
          const light = new THREE.PointLight(0xffffff, 1.2, 22);
          light.position.copy(lightPos);
          scene.add(light);
          const lamp = new THREE.Mesh(
            new THREE.BoxGeometry(1.2, 0.5, 1.2),
            new THREE.MeshStandardMaterial({ color: 0xfafafa, emissive: 0xffffff, emissiveIntensity: 0.7 })
          );
          lamp.position.copy(lightPos);
          scene.add(lamp);
        }
      }
      addCurvedTunnel();

      // Barreiras metálicas apenas onde y está entre -8 e 0
      const barrierMaterial = new THREE.MeshStandardMaterial({ map: metalTexture, color: 0xb0b0b0, metalness: 0.8, roughness: 0.3 });
      const barrierHeight = 1.2;
      const barrierWidth = 0.25;
      const barrierLength = 3;
      const barrierYOffset = barrierHeight / 2 + 0.1;
      const barrierSegments = 220;
      const postHeight = 4.5;
      const postRadius = 0.12;
      const barRadius = 0.07;
      const barsPerBarrier = 4;
      const barrierOffset = 0.2; // afastar um pouco da pista

      const tStartBarrier = 0.04; // não mete barreiras no início
      const tTunnelStart = 0.36;  // início do túnel
      const tTunnelEnd = 0.44;    // fim do túnel
      const tEndBarrier = 0.94;   // não mete barreiras no final (ajuste se necessário)

      for (let i = 0; i < barrierSegments; i++) {
        const t1 = i / barrierSegments;
        const t2 = (i + 1) / barrierSegments;
        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);

        // Saltar barreiras no início, túnel e final da pista
        if (
          t1 < tStartBarrier ||
          (t1 > tTunnelStart && t1 < tTunnelEnd) ||
          t1 > tEndBarrier
        ) continue;

        // Só criar barreira se ambos os pontos estão entre -8 e 0 (inclusive)
        if (p1.y <= 0 && p1.y >= -8 && p2.y <= 0 && p2.y >= -8) {
          const tangent = curve.getTangent(t1);
          const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

          [-1, 1].forEach(side => {
            const edge1 = new THREE.Vector3().copy(p1).addScaledVector(normal, side * (planeWidth / 2 + barrierOffset));
            const edge2 = new THREE.Vector3().copy(p2).addScaledVector(normal, side * (planeWidth / 2 + barrierOffset));

            [edge1, edge2].forEach(pos => {
              const post = new THREE.Mesh(
                new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 10),
                new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8 })
              );
              post.position.set(pos.x, pos.y + postHeight / 2, pos.z);
              post.castShadow = true;
              post.receiveShadow = true;
              scene.add(post);
            });

            for (let b = 0; b < barsPerBarrier; b++) {
              const yBar = p1.y + 0.7 + (b * (postHeight - 1.2) / (barsPerBarrier - 1));
              const bar = new THREE.Mesh(
                new THREE.CylinderGeometry(barRadius, barRadius, edge1.distanceTo(edge2), 8),
                new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7 })
              );
              bar.position.set(
                (edge1.x + edge2.x) / 2,
                yBar,
                (edge1.z + edge2.z) / 2
              );
              bar.lookAt(edge2.x, yBar, edge2.z);
              bar.rotateX(Math.PI / 2);
              bar.castShadow = true;
              bar.receiveShadow = true;
              scene.add(bar);
            }
          });
        }
      }

      // Posição de partida personalizada (atrás do início)
      monacoStartLinePosition = curve.getPointAt(tStart);

      // Novo semáforo para Mónaco
      function createMonacoSemaphore() {
        const startPoint = curve.getPointAt(tStart);
        const startTangent = curve.getTangentAt(tStart);
        const perpendicular = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();

        // Postes laterais
        const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 32);
        const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const pole1 = new THREE.Mesh(poleGeometry, poleMaterial);
        pole1.position.copy(startPoint).addScaledVector(perpendicular, -planeWidth / 2);
        pole1.position.y = 2.5;
        scene.add(pole1);
        const pole2 = new THREE.Mesh(poleGeometry, poleMaterial);
        pole2.position.copy(startPoint).addScaledVector(perpendicular, planeWidth / 2);
        pole2.position.y = 2.5;
        scene.add(pole2);

        // Barra superior
        const barGeometry = new THREE.BoxGeometry(planeWidth, 0.3, 0.3);
        const barMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const bar = new THREE.Mesh(barGeometry, barMaterial);
        bar.position.copy(startPoint);
        bar.position.y = 5;
        bar.lookAt(bar.position.clone().add(startTangent));
        scene.add(bar);

        // Semáforos (5 luzes vermelhas)
        const lightGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const lights = [];
        const lightSpacing = planeWidth / 6;
        for (let i = 0; i < 5; i++) {
          const redLightMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
          const light = new THREE.Mesh(lightGeometry, redLightMaterial);
          light.position.copy(startPoint);
          light.position.y = 5;
          light.position.addScaledVector(perpendicular, -planeWidth / 2 + lightSpacing * (i + 1));
          scene.add(light);
          lights.push(light);
        }
        return lights;
      }

      // Nova linha de partida para Mónaco
      function createMonacoStartLine() {
        const finishMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const finishGeometry = new THREE.PlaneGeometry(planeWidth, 0.2);
        const finishLine = new THREE.Mesh(finishGeometry, finishMaterial);

        // Alinhar com a tangente da pista na posição de partida
        finishLine.rotation.x = -Math.PI / 2;
        const startTangent = curve.getTangentAt(tStart);
        finishLine.rotation.z = Math.atan2(startTangent.x, startTangent.z);

        // Colocar exatamente à altura da pista naquele ponto
        finishLine.position.copy(monacoStartLinePosition);
        finishLine.position.y = monacoStartLinePosition.y + 0.02; // ligeiramente acima da pista

        scene.add(finishLine);
      }

      // Substituir as chamadas originais:
      lights = createMonacoSemaphore();
      createMonacoStartLine();

      // Ajustar a posição inicial do carro:
      carModel.position.copy(monacoStartLinePosition);
      carDirection = Math.atan2(startTangent.x, startTangent.z);
      carModel.rotation.y = carDirection;

      addMonacoTrackLines(curve, planeWidth);

      startRaceCountdown();
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', (e) => {
        if (e.key === 'a' || e.key === 'ArrowLeft') moveLeft = true;
        if (e.key === 'd' || e.key === 'ArrowRight') moveRight = true;
        if (e.key === 'w' || e.key === 'ArrowUp') moveUp = true;
        if (e.key === 's' || e.key === 'ArrowDown') moveDown = true;
        if (e.key === 'r') reverse = true;
        if (e.key === 'p') {
          firstPersonView = !firstPersonView;
          thirdPersonView = !firstPersonView;
        }
        if (e.key === 'b') {
          frontView = true;
        }
      });
      document.addEventListener('keyup', (e) => {
        if (e.key === 'a' || e.key === 'ArrowLeft') moveLeft = false;
        if (e.key === 'd' || e.key === 'ArrowRight') moveRight = false;
        if (e.key === 'w' || e.key === 'ArrowUp') moveUp = false;
        if (e.key === 's' || e.key === 'ArrowDown') moveDown = false;
        if (e.key === 'r') reverse = false;
        if (e.key === 'b') frontView = false;
      });
    }

    function createTrack() {
      // Traçado da pista original (plano, sem subidas/descidas)
      const points = [
        new THREE.Vector3(0, 0, -200), // Reta de partida
        new THREE.Vector3(50, 0, -200), // Curva 1
        new THREE.Vector3(100, 0, -150), // Curva 2
        new THREE.Vector3(150, 0, -100), // Curva 3
        new THREE.Vector3(200, 0, -50), // Curva 4
        new THREE.Vector3(150, 0, 0), // Curva 5
        new THREE.Vector3(100, 0, 50), // Curva 6
        new THREE.Vector3(50, 0, 100), // Curva 7
        new THREE.Vector3(0, 0, 150), // Curva 8
        new THREE.Vector3(-50, 0, 100), // Curva 9
        new THREE.Vector3(-100, 0, 50), // Curva 10
        new THREE.Vector3(-150, 0, 0), // Curva 11
        new THREE.Vector3(-200, 0, -50), // Curva 12
        new THREE.Vector3(-150, 0, -100), // Curva 13
        new THREE.Vector3(-100, 0, -150), // Curva 14
        new THREE.Vector3(-50, 0, -200), // Curva 15
        new THREE.Vector3(0, 0, -200) // Fechar o circuito
      ];
      curve = new THREE.CatmullRomCurve3(points, true);

      const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const divisions = 500;

      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];

      for (let i = 0; i < divisions; i++) {
        const t1 = i / divisions;
        const t2 = (i + 1) / divisions;

        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);

        const tangent1 = curve.getTangent(t1);
        const tangent2 = curve.getTangent(t2);

        const normal1 = new THREE.Vector3(-tangent1.z, 0, tangent1.x).normalize();
        const normal2 = new THREE.Vector3(-tangent2.z, 0, tangent2.x).normalize();

        const left1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, -planeWidth / 2);
        const right1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, planeWidth / 2);
        const left2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, -planeWidth / 2);
        const right2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, planeWidth / 2);

        const baseIndex = vertices.length / 3;

        vertices.push(
          left1.x, left1.y, left1.z,
          right1.x, right1.y, right1.z,
          left2.x, left2.y, left2.z,
          right2.x, right2.y, right2.z
        );

        indices.push(
          baseIndex, baseIndex + 1, baseIndex + 2,
          baseIndex + 1, baseIndex + 3, baseIndex + 2
        );
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      const track = new THREE.Mesh(geometry, trackMaterial);

      track.receiveShadow = true;
      track.castShadow = true;
      scene.add(track);

      // Adicionar bordas planas
      addFlatBorders(curve, planeWidth);
    }

    function addFlatBorders(curve, planeWidth) {
      const borderWidth = 2; // Largura da borda
      const borderHeight = 0.3; // Altura da borda (lomba)
      const borderSegments = 500;
      const borderColors = [0xff0000, 0xffffff];

      for (let i = 0; i < borderSegments; i++) {
        const t1 = i / borderSegments;
        const t2 = (i + 1) / borderSegments;

        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);

        const tangent = new THREE.Vector3().subVectors(p2, p1).normalize();
        const direction = new THREE.Vector3().copy(tangent).normalize();
        const up = new THREE.Vector3(0, 1, 0);
        const right = new THREE.Vector3().crossVectors(up, direction).normalize();

        const segmentLength = p1.distanceTo(p2);

        // Criar uma geometria que siga a orientação do segmento
        const createBorder = (offset, color) => {
          const center = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
          const sideOffset = new THREE.Vector3().copy(right).multiplyScalar(offset);
          center.add(sideOffset);

          // Usar BoxGeometry para criar bordas com altura
          const geometry = new THREE.BoxGeometry(
            segmentLength, // Comprimento do segmento
            borderHeight,  // Altura da borda
            borderWidth    // Largura da borda
          );
          const material = new THREE.MeshStandardMaterial({ color });
          const mesh = new THREE.Mesh(geometry, material);

          // Alinhar com a pista
          const quaternion = new THREE.Quaternion();
          quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
          mesh.quaternion.copy(quaternion);

          // Posicionar no mesmo nível da pista
          mesh.position.copy(center);
          mesh.position.y += borderHeight / 2; // Elevar para que a altura fique visível

          scene.add(mesh);
        };

        const color = borderColors[i % 2];
        createBorder(-planeWidth / 2 - borderWidth / 2, color); // Esquerda
        createBorder(planeWidth / 2 + borderWidth / 2, color);  // Direita
      }
    }

    let collisionCount = 0; // Contador de colisões

    function checkCollisionWithBorders(car, curve, planeWidth) {
      if (!curve) return;
      const divisions = 500; // Mais precisão para curvas
      let closestPoint = null;
      let minDist = Infinity;
      let closestT = 0;
      for (let i = 0; i <= divisions; i++) {
        const t = i / divisions;
        const point = curve.getPoint(t);
        if (!point) continue;
        const dx = point.x - car.position.x;
        const dz = point.z - car.position.z;
        const distSq = dx * dx + dz * dz;
        if (distSq < minDist) {
          minDist = distSq;
          closestPoint = point;
          closestT = t;
        }
      }
      if (!closestPoint) return;
      // Calcular a direção perpendicular à pista no ponto mais próximo
      const tangent = curve.getTangent(closestT);
      if (!tangent) return;
      const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
      // Calcular a distância do carro ao centro da pista
      const offset = new THREE.Vector3().subVectors(car.position, closestPoint);
      const distanceToCenter = offset.dot(perpendicular);
      // Permitir uma margem maior nas retas (onde z é próximo de 0 ou -220)
      let extraMargin = 0;
      if (Math.abs(car.position.z) < 10 || Math.abs(car.position.z + 220) < 10) {
        extraMargin = 8; // margem extra nas retas
      }
      // Corrigir bug: só detetar colisão se o carro estiver realmente fora da geometria da pista
      // Verificar também a distância ao ponto mais próximo (para evitar bug em curvas)
      const maxDistToCenter = planeWidth / 2 + extraMargin;
      const distToCenter2D = Math.sqrt(
        Math.pow(car.position.x - closestPoint.x, 2) +
        Math.pow(car.position.z - closestPoint.z, 2)
      );
      if (Math.abs(distanceToCenter) > maxDistToCenter && distToCenter2D > maxDistToCenter) {
        collisionCount++;
        console.log(`Colisão detectada! Total de colisões: ${collisionCount}`);
        // Reposicionar o carro dentro dos limites da pista
        const clampedDistance = Math.sign(distanceToCenter) * (maxDistToCenter - 0.5);
        car.position.copy(closestPoint).addScaledVector(perpendicular, clampedDistance);
        currentSpeed *= 0.5;
      }
    }

    //Animação do semáforo
    function startRaceCountdown() {
      let index = 0;
      const interval = setInterval(() => {
        if (index < lights.length) {
          lights[index].material.color.set(0x333333); // Apaga a luz
          index++;
        } else {
          clearInterval(interval); // Para o intervalo quando todas as luzes forem apagadas
          console.log('Corrida iniciada!');
        }
      }, 2000); // Apaga uma luz a cada 2 segundos
    }

    //Criação do semáforo
    function createSemaphore() {
      const startPoint = curve.getPoint(0);
      // Para garantir alinhamento, usar a tangente da reta inicial
      const startTangent = curve.getTangent(0);
      // Corrigir: usar tangente da reta inicial para garantir alinhamento perfeito
      const perpendicular = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();
      // Postes laterais alinhados exatamente com a largura da pista
      const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 32);
      const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const pole1 = new THREE.Mesh(poleGeometry, poleMaterial);
      pole1.position.copy(startPoint).addScaledVector(perpendicular, -planeWidth / 2);
      pole1.position.y = 2.5;
      scene.add(pole1);
      const pole2 = new THREE.Mesh(poleGeometry, poleMaterial);
      pole2.position.copy(startPoint).addScaledVector(perpendicular, planeWidth / 2);
      pole2.position.y = 2.5;
      scene.add(pole2);
      // Barra superior
      const barGeometry = new THREE.BoxGeometry(planeWidth, 0.3, 0.3);
      const barMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const bar = new THREE.Mesh(barGeometry, barMaterial);
      bar.position.copy(startPoint);
      bar.position.y = 5;
      // Alinhar bar com a tangente da reta inicial
      bar.lookAt(bar.position.clone().add(startTangent));
      scene.add(bar);
      // Semáforos (5 luzes vermelhas)
      const lightGeometry = new THREE.SphereGeometry(0.3, 32, 32);
      const lights = [];
      const lightSpacing = planeWidth / 6;
      for (let i = 0; i < 5; i++) {
        const redLightMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const light = new THREE.Mesh(lightGeometry, redLightMaterial);
        light.position.copy(startPoint);
        light.position.y = 5;
        light.position.addScaledVector(perpendicular, -planeWidth / 2 + lightSpacing * (i + 1));
        scene.add(light);
        lights.push(light);
      }
      return lights;
    }

    function createStartingGrid() {
      const numLines = 10; // Número de linhas de posição
      const lineSpacing = 0.02; // Reduzir ainda mais a distância entre as linhas ao longo do eixo da pista
      const trackWidth = 10; // Largura da pista
      const padding = 1; // Espaçamento das linhas em relação às bordas da pista

      for (let i = 0; i < numLines; i++) {
        // Ajustar o valor inicial de t para começar bem atrás da linha de chegada
        const t = -0.05 - i * lineSpacing; // Começar mais atrás e reduzir o espaçamento

        // Obter o ponto e a tangente da curva para a posição da linha
        const linePoint = curve.getPointAt((1 + t) % 1); // Garantir que o valor de t esteja no intervalo [0, 1]
        const lineTangent = curve.getTangentAt((1 + t) % 1);
        const perpendicular = new THREE.Vector3(-lineTangent.z, 0, lineTangent.x).normalize(); // Direção perpendicular à pista

        // Criar a linha
        const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Material branco
        const lineGeometry = new THREE.PlaneGeometry(2, 0.1); // Geometria para as linhas de posição
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI / 2; // Alinhar com o chão
        line.rotation.z = Math.PI / 2; // Garantir que as linhas fiquem paralelas à pista

        // Alternar entre direita e esquerda
        const direction = i % 2 === 0 ? 1 : -1; // Direita (1) ou esquerda (-1)

        // Calcular a posição da linha com base na borda da pista
        const offset = direction * (trackWidth / 2 - padding); // Ajustar para a borda correspondente
        line.position.copy(linePoint).addScaledVector(perpendicular, offset); // Ajustar no eixo perpendicular
        line.position.y = 0.01; // Elevar ligeiramente para evitar sobreposição com a pista

        scene.add(line);
      }
    }

    function createFinishLine() {
      const finishPoint = curve.getPoint(0); // Ponto próximo ao final da pista
      startLinePosition = finishPoint.clone(); // Armazenar a posição da linha de chegada

      const finishMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Material branco
      const finishGeometry = new THREE.PlaneGeometry(planeWidth, 0.2); // Geometria para a linha de chegada

      const finishLine = new THREE.Mesh(finishGeometry, finishMaterial);
      finishLine.rotation.x = -Math.PI / 2; // Alinhar com o chão
      finishLine.rotation.z = Math.PI / 2; // Garantir que a linha fique paralela à pista
      finishLine.position.copy(finishPoint);
      finishLine.position.y = 0.01; // Elevar ligeiramente para evitar sobreposição com a pista
      scene.add(finishLine);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Atualiza animação do Shrek se necessário
      if (shrekMixer) {
        const delta = clock.getDelta();
        shrekMixer.update(delta);
      }

      if (carModel && curve) {
        // Aceleração progressiva with 'w'
        if (moveUp) {
          currentSpeed += acceleration;
          if (currentSpeed > maxSpeed) currentSpeed = maxSpeed;
        }
        // Frenagem with 's'
        if (moveDown) {
          currentSpeed -= braking;
          if (currentSpeed < 0) currentSpeed = 0;
        }
        // Marcha à ré with 'r'
        if (reverse) {
          currentSpeed -= acceleration;
          if (currentSpeed < -maxSpeed / 8) currentSpeed = -maxSpeed / 8;
        }
        // Reduzir a velocidade gradualmente quando nenhuma tecla é pressionada
        if (!moveUp && !moveDown && !reverse) {
          currentSpeed *= 0.98;
          if (currentSpeed < 0.01 && currentSpeed > -0.01) currentSpeed = 0;
        }
        // Reduzir a velocidade ao virar
        if (moveLeft || moveRight) {
          currentSpeed *= 0.99;
        }
        // Atualizar a posição do carro
        carModel.position.x += Math.sin(carDirection) * currentSpeed;
        carModel.position.z += Math.cos(carDirection) * currentSpeed;
        // Atualizar a rotação do carro
        if (moveLeft) carDirection += turnSpeed;
        if (moveRight) carDirection -= turnSpeed;

        // Suavizar a altura do carro ao longo da pista, evitando desfasamentos
        let closestY = 0;
        let minDist = Infinity;
        const divisions = 400;
        for (let i = 0; i <= divisions; i++) {
          const t = i / divisions;
          const point = curve.getPoint(t);
          const dx = point.x - carModel.position.x;
          const dz = point.z - carModel.position.z;
          const distSq = dx * dx + dz * dz;
          if (distSq < minDist) {
            minDist = distSq;
            closestY = point.y;
          }
        }
        // Para pista plana, não somar offset extra
        if (selectedTrack === 'default') {
          carModel.position.y = closestY;
        } else {
          // Suavização: usar lerp para evitar saltos bruscos mas sem atraso acumulado
          if (carModel.lastY === undefined) carModel.lastY = closestY;
          const lerpFactor = 0.5; // mais responsivo
          carModel.lastY = carModel.lastY + (closestY - carModel.lastY) * lerpFactor;
          // Offset para garantir que as rodas tocam a pista (ajuste conforme modelo)
          const wheelOffset = 0.25;
          carModel.position.y = carModel.lastY + wheelOffset;
        }
        carModel.rotation.y = carDirection;

        // Verificar colisão com as bordas da pista
        checkCollisionWithBorders(carModel, curve, planeWidth);

        // Atualizar o display do tempo
        const lapTimesDiv = document.getElementById('lap-times');
        if (lapTimesDiv) {
          lapTimesDiv.innerHTML = `Voltas:<br>`;
          lapTimes.forEach((time, index) => {
            lapTimesDiv.innerHTML += `Volta ${index + 1}: ${time.toFixed(2)}s<br>`;
          });
        } else {
          console.error("Elemento 'lap-times' não encontrado!");
        }

        // Atualizar a posição da câmera para ficar atrás do carro
        const cameraOffset = 10;
        const cameraHeight = 5;

        if (frontView) {
          camera.position.set(
            carModel.position.x,
            carModel.position.y + 1.5,
            carModel.position.z
          );
          camera.rotation.set(0, carDirection, 0);
        } else if (firstPersonView) {
          camera.position.set(
            carModel.position.x + Math.sin(carDirection) * 1.2,
            carModel.position.y + 1.5,
            carModel.position.z + Math.cos(carDirection) * 1.2
          );
          camera.lookAt(
            carModel.position.x + Math.sin(carDirection) * 10,
            carModel.position.y + 1.5,
            carModel.position.z + Math.cos(carDirection) * 10
          );
        } else {
          camera.position.set(
            carModel.position.x - Math.sin(carDirection) * cameraOffset,
            carModel.position.y + cameraHeight,
            carModel.position.z - Math.cos(carDirection) * cameraOffset
          );
          camera.lookAt(carModel.position);
        }

        // Detetar quando o carro completa uma volta
        if (selectedTrack === 'monaco' && monacoStartLinePosition) {
          const distanceToStart = carModel.position.distanceTo(monacoStartLinePosition);
          // Melhorar detecção de passagem pela linha de chegada: usar projeção na largura da pista
          if (monacoStartLinePosition) {
            // Calcular tangente e perpendicular à pista na linha de chegada
            const startTangent = curve.getTangent(0);
            const startPerp = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();
            // Projeção do carro na direção perpendicular à linha
            const offset = new THREE.Vector3().subVectors(carModel.position, monacoStartLinePosition);
            const lateralDist = offset.dot(startPerp);
            // Usar tolerância igual à largura da pista (incluindo metade do carro)
            const tolerance = planeWidth / 2 + 4.5; // 4.5 cobre metade do carro e mais folga
            if (Math.abs(lateralDist) < tolerance) {
              if (distanceToStart < 12) // tolerância maior para extremidades
                if (!passedStartLine) {
                  passedStartLine = true;
                  const currentTime = performance.now();
                  if (lapStartTime === 0) {
                    lapStartTime = currentTime;
                  } else {
                    const lapTime = (currentTime - lapStartTime) / 1000;
                    lapTimes.push(lapTime);
                    lapStartTime = currentTime;
                    console.log(`Volta ${lapTimes.length}: ${lapTime.toFixed(2)} segundos`);
                  }
                }
            } else {
              passedStartLine = false;
            }
          } else {
            passedStartLine = false;
          }
        } else if (selectedTrack === 'default' && startLinePosition) {
          const distanceToStart = carModel.position.distanceTo(startLinePosition);
          // Melhorar detecção de passagem pela linha de chegada: usar projeção na largura da pista
          if (startLinePosition) {
            // Calcular tangente e perpendicular à pista na linha de chegada
            const startTangent = curve.getTangent(0);
            const startPerp = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();
            // Projeção do carro na direção perpendicular à linha
            const offset = new THREE.Vector3().subVectors(carModel.position, startLinePosition);
            const lateralDist = offset.dot(startPerp);
            // Usar tolerância igual à largura da pista (incluindo metade do carro)
            const tolerance = planeWidth / 2 + 4.5; // 4.5 cobre metade do carro e mais folga
            if (Math.abs(lateralDist) < tolerance) {
              if (distanceToStart < 12) // tolerância maior para extremidades
                if (!passedStartLine) {
                  passedStartLine = true;
                  const currentTime = performance.now();
                  if (lapStartTime === 0) {
                    lapStartTime = currentTime;
                  } else {
                    const lapTime = (currentTime - lapStartTime) / 1000;
                    lapTimes.push(lapTime);
                    lapStartTime = currentTime;
                    console.log(`Volta ${lapTimes.length}: ${lapTime.toFixed(2)} segundos`);
                  }
                }
            } else {
              passedStartLine = false;
            }
          } else {
            passedStartLine = false;
          }
        } else {
          passedStartLine = false;
        }
      }

      if (window.waterTexture) {
        const time = performance.now() * 0.00003; // tempo em segundos, escala lenta
        window.waterTexture.offset.x = Math.sin(time) * 0.03; // oscila entre -0.08 e 0.08
        window.waterTexture.offset.y = 0;
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('resize', onWindowResize);

    function addMonacoTrackLines(curve, planeWidth) {
      const numDashes = 80; // Quantos traços ao longo da pista
      const dashLength = 0.9; // Comprimento de cada traço
      const gap = 0.7; // Espaço entre traços

      for (let i = 0; i < numDashes; i++) {
        const t = i / numDashes;
        const point = curve.getPointAt(t);
        const tangent = curve.getTangentAt(t);

        // Linha branca centrada (tracejada)
        const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const lineGeometry = new THREE.PlaneGeometry(dashLength, 0.18);
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI / 2;
        line.position.copy(point);
        line.position.y += 0.04; // ligeiramente acima da pista

        // Alinhar a linha com a pista
        line.rotation.z = Math.atan2(tangent.x, tangent.z);

        scene.add(line);
      }
    }

    // Adicionar as linhas da pista de Mónaco
    addMonacoTrackLines(curve, planeWidth);

  </script>
</body>
</html>