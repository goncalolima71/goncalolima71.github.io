<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8">
  <title>Jogo de F1 3D</title>
  <script>
    const isLocal = window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost";
    const base = document.createElement("base");
    base.href = isLocal ? "/" : "/goncalolima71.github.io/";
    document.head.appendChild(base);
  </script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #start-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #car-selection {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
    }
    .car-option {
      border: 3px solid transparent;
      border-radius: 10px;
      background: #333;
      padding: 10px;
      cursor: pointer;
      transition: border 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .car-option.selected {
      border: 3px solid #007bff;
      background: #222;
    }
    .car-thumb {
      width: 100px;
      height: 60px;
      object-fit: contain;
      margin-bottom: 10px;
      background: #111;
      border-radius: 5px;
    }
    #start-btn {
      padding: 20px 40px;
      font-size: 2rem;
      border: none;
      border-radius: 10px;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      margin-top: 30px;
      transition: background 0.2s;
    }
    #start-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }
    #loading-circle {
      width: 60px;
      height: 60px;
      border: 8px solid #eee;
      border-top: 8px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
      display: none;
    }
    @keyframes spin {
      0% { transform: rotate(0deg);}
      100% { transform: rotate(360deg);}
    }
    #lap-times {
      position: absolute; top: 10px; left: 10px;
      color: rgb(239, 239, 239); font-size: 20px;
      background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px;
      z-index: 1;
      display: none;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <!-- Menu inicial -->
  <div id="start-screen">
    <div id="car-selection">
      <div class="car-option selected" data-model="aston_martin_f1_amr23_2023.glb">
        <span>Aston Martin AMR23</span>
      </div>
      <div class="car-option" data-model="scuderia_ferrari_f1_sf23_2023.glb">
        <span>Ferrari SF23</span>
      </div>
      <div class="car-option" data-model="mclaren_mcl60_f1_2023.glb">
        <span>McLaren MCL60</span>
      </div>
      <div class="car-option" data-model="mclaren_mp45__formula_1.glb">
        <span>McLaren MP4/5</span>
      </div>
      <div class="car-option" data-model="shrek_hip_hop_dance.glb">
        <span>Shrek</span>
      </div>
    </div>
    <div id="loading-circle"></div>
    <button id="start-btn">Start</button>
  </div>
  <div id="lap-times">
    Tempo da volta:
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // Variáveis
    let scene, camera, renderer, carModel;
    let moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
    let currentSpeed = 0;
    const maxSpeed = 1;
    const acceleration = 0.01;
    const braking = 0.02;
    const turnSpeed = 0.01;
    let carDirection = 0;
    let curve;
    let reverse = false;
    let planeWidth = 20;
    let thirdPersonView = true;
    let frontView = false;
    let firstPersonView = false;
    let lapStartTime = 0;
    let lapTimes = [];
    let currentLap = 0;
    let passedStartLine = false;
    let startLinePosition;
    let lights = [];
    let shrekMixer = null; // Para animação do Shrek
    const clock = new THREE.Clock();

    // Elementos da UI
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    const loadingCircle = document.getElementById('loading-circle');
    const lapTimesDiv = document.getElementById('lap-times');
    const carOptions = document.querySelectorAll('.car-option');

    // Estado inicial
    loadingCircle.style.display = 'none';
    startBtn.disabled = false;

    // Seleção de carro
    let selectedModel = carOptions[0].dataset.model;
    carOptions.forEach(option => {
      option.addEventListener('click', () => {
        carOptions.forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedModel = option.dataset.model;
      });
    });

    // Ao clicar em Start, carrega o modelo escolhido
    startBtn.addEventListener('click', () => {
      startBtn.disabled = true;
      loadingCircle.style.display = 'block';

      const loader = new GLTFLoader();
      const modelPath = isLocal
        ? `./${selectedModel}`
        : `/goncalolima71.github.io/${selectedModel}`;

      loader.load(
        modelPath,
        (gltf) => {
          loadingCircle.style.display = 'none';
          startScreen.style.display = 'none';
          lapTimesDiv.style.display = 'block';

          // Ajuste de escala e rotação conforme o modelo selecionado
          const carModelLoaded = gltf.scene;
          shrekMixer = null; // Limpa mixer anterior

          switch (selectedModel) {
            case "aston_martin_f1_amr23_2023.glb":
              carModelLoaded.scale.set(1.2, 1.2, 1.2);
              carModelLoaded.rotation.y = Math.PI;
              break;
            case "scuderia_ferrari_f1_sf23_2023.glb":
              carModelLoaded.scale.set(1.2, 1.2, 1.2);
              carModelLoaded.rotation.y = Math.PI;
              break;
            case "mclaren_mcl60_f1_2023.glb":
              carModelLoaded.scale.set(1.2, 1.2, 1.2);
              carModelLoaded.rotation.y = Math.PI;
              break;
            case "mclaren_mp45__formula_1.glb":
              carModelLoaded.scale.set(0.5, 0.5, 0.5);
              break;
            case "shrek_hip_hop_dance.glb":
              carModelLoaded.scale.set(0.7, 0.7, 0.7); // Shrek menor
              carModelLoaded.rotation.y = Math.PI;
              // Ativar animação de caminhada se existir
              if (gltf.animations && gltf.animations.length > 0) {
                shrekMixer = new THREE.AnimationMixer(carModelLoaded);
                const action = shrekMixer.clipAction(gltf.animations[0]);
                action.play();
                action.timeScale = 1.5; // Shrek anda mais rápido
              }
              break;
            default:
              carModelLoaded.scale.set(1.2, 1.2, 1.2);
          }

          init(carModelLoaded);
          animate();
        },
        undefined,
        (error) => {
          loadingCircle.style.display = 'none';
          startBtn.innerText = "Erro ao carregar modelo!";
          startBtn.disabled = true;
          console.error('Erro ao carregar o modelo:', error);
        }
      );
    });

    function init(loadedCarModel) {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Luz ambiente mais forte
      scene.add(new THREE.AmbientLight(0xffffff, 1.5));
      // Luz direcional extra para iluminar melhor o carro
      const light = new THREE.DirectionalLight(0xffffff, 1.5);
      light.position.set(0, 20, 20);
      light.castShadow = true;
      scene.add(light);

      // CRIAR A PISTA ANTES DE USAR curve!
      createTrack();

      // Criar semáforo e guardar as luzes
      lights = createSemaphore();
      createStartingGrid();
      createFinishLine();

      const startPoint = curve.getPoint(0);
      const startTangent = curve.getTangent(0);

      carModel = loadedCarModel;
      carModel.position.copy(startPoint);
      carDirection = Math.atan2(startTangent.x, startTangent.z);
      carModel.rotation.y += carDirection;

      carModel.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
        }
      });

      scene.add(carModel);

      // Fundo de relva grande
      const grassGeometry = new THREE.PlaneGeometry(2000, 2000);
      const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x7ec850 });
      const grass = new THREE.Mesh(grassGeometry, grassMaterial);
      grass.rotation.x = -Math.PI / 2;
      grass.position.y = -0.02;
      scene.add(grass);

      // Função para verificar se um ponto está dentro dos limites da pista
      function isPointNearTrack(x, z, minDist = planeWidth / 2 + 8) {
        if (!curve) return false;
        let closestDist = Infinity;
        const divisions = 500;
        for (let i = 0; i <= divisions; i++) {
          const t = i / divisions;
          const point = curve.getPoint(t);
          const dx = point.x - x;
          const dz = point.z - z;
          const distSq = dx * dx + dz * dz;
          if (distSq < closestDist) closestDist = distSq;
        }
        return Math.sqrt(closestDist) < minDist;
      }

      // Função para adicionar árvores maiores e variadas
      function addTree(x, z, type = 0) {
        let trunk, crown;
        if (type === 0) {
          // Árvore redonda grande
          trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.5, 5),
            new THREE.MeshStandardMaterial({ color: 0x8b5a2b })
          );
          trunk.position.set(x, 2.5, z);

          crown = new THREE.Mesh(
            new THREE.SphereGeometry(2.2, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x267f00 })
          );
          crown.position.set(x, 6, z);
        } else {
          // Árvore tipo pinheiro grande
          trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 4),
            new THREE.MeshStandardMaterial({ color: 0x6b4226 })
          );
          trunk.position.set(x, 2, z);

          crown = new THREE.Mesh(
            new THREE.ConeGeometry(2, 4, 12),
            new THREE.MeshStandardMaterial({ color: 0x1b5e20 })
          );
          crown.position.set(x, 5, z);
        }
        scene.add(trunk);
        scene.add(crown);
      }

      // Adicionar muitas árvores maiores e mais juntas à volta da pista, evitando a pista
      let treesPlaced = 0;
      let tries = 0;
      const totalTrees = 180;
      while (treesPlaced < totalTrees && tries < totalTrees * 8) {
        tries++;
        const angle = Math.random() * Math.PI * 2;
        const radius = 120 + Math.random() * 80; // Mais perto da pista
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        if (!isPointNearTrack(x, z, planeWidth / 2 + 7)) { // margem menor para ficarem mais juntas
          const type = Math.random() > 0.5 ? 1 : 0;
          addTree(x, z, type);
          treesPlaced++;
        }
      }

      // Função para adicionar bancadas abertas e viradas para a pista, junto às bordas
      function addGrandstandFacingTrack(t, dist, width = 28, depth = 6, height = 4, color = 0xcccccc) {
        // t: valor entre 0 e 1 ao longo da curva
        const point = curve.getPointAt(t);
        const tangent = curve.getTangentAt(t);
        const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

        // Posição da bancada fora da pista
        const pos = new THREE.Vector3().copy(point).addScaledVector(perpendicular, dist);

        // Base da bancada
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(width, 0.5, depth),
          new THREE.MeshStandardMaterial({ color })
        );
        base.position.copy(pos);
        base.position.y += 0.25;

        // Costas da bancada (atrás) - agora do lado oposto ao público
        const back = new THREE.Mesh(
          new THREE.BoxGeometry(width, height, 0.3),
          new THREE.MeshStandardMaterial({ color: 0x888888 })
        );
        back.position.copy(pos);
        back.position.y += height / 2;
        // Colocar atrás da base, afastando no sentido do perpendicular PARA FORA da pista
        back.position.x += perpendicular.x * (depth / 2 - 0.15);
        back.position.z += perpendicular.z * (depth / 2 - 0.15);

        // Orientar ambos para a pista (para o ponto da pista mais próximo)
        base.lookAt(point.x, base.position.y, point.z);
        back.lookAt(point.x, back.position.y, point.z);

        scene.add(base);
        scene.add(back);

        // Público em filas, alinhado com a bancada e virado para a pista
        for (let i = 0; i < width - 2; i += 2) {
          for (let j = 0; j < 3; j++) {
            const fan = new THREE.Mesh(
              new THREE.SphereGeometry(0.5, 8, 8),
              new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
            );
            // Distribuir os adeptos em filas, alinhados com a base da bancada
            const offsetDepth = depth / 2 - 1.2 - j * 1.2; // Fica do lado aberto
            fan.position.set(
              base.position.x + perpendicular.x * offsetDepth + tangent.x * (i - width / 2 + 2),
              base.position.y + 0.8,
              base.position.z + perpendicular.z * offsetDepth + tangent.z * (i - width / 2 + 2)
            );
            fan.lookAt(point.x, fan.position.y, point.z);
            scene.add(fan);
          }
        }
      }

      // Colocar bancadas junto às bordas da pista e viradas para a pista
      addGrandstandFacingTrack(0.08, planeWidth / 2 + 8, 28, 6, 4, 0xcccccc);
      addGrandstandFacingTrack(0.32, -(planeWidth / 2 + 8), 22, 6, 4, 0x888888);
      addGrandstandFacingTrack(0.62, planeWidth / 2 + 8, 24, 6, 4, 0xbbbbbb);

      startRaceCountdown();

      window.addEventListener('resize', onWindowResize);

      document.addEventListener('keydown', (e) => {
        if (e.key === 'a' || e.key === 'ArrowLeft') moveLeft = true;
        if (e.key === 'd' || e.key === 'ArrowRight') moveRight = true;
        if (e.key === 'w' || e.key === 'ArrowUp') moveUp = true;
        if (e.key === 's' || e.key === 'ArrowDown') moveDown = true;
        if (e.key === 'r') reverse = true;
        if (e.key === 'p') {
          firstPersonView = !firstPersonView;
          thirdPersonView = !firstPersonView;
        }
        if (e.key === 'b') {
          frontView = true;
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.key === 'a' || e.key === 'ArrowLeft') moveLeft = false;
        if (e.key === 'd' || e.key === 'ArrowRight') moveRight = false;
        if (e.key === 'w' || e.key === 'ArrowUp') moveUp = false;
        if (e.key === 's' || e.key === 'ArrowDown') moveDown = false;
        if (e.key === 'r') reverse = false;
        if (e.key === 'b') frontView = false;
      });
    }

    function createTrack() {
      const points = [
        new THREE.Vector3(0, 0, -200), // Reta de partida
        new THREE.Vector3(50, 0, -200), // Curva 1
        new THREE.Vector3(100, 0, -150), // Curva 2
        new THREE.Vector3(150, 0, -100), // Curva 3
        new THREE.Vector3(200, 0, -50), // Curva 4
        new THREE.Vector3(150, 0, 0), // Curva 5
        new THREE.Vector3(100, 0, 50), // Curva 6
        new THREE.Vector3(50, 0, 100), // Curva 7
        new THREE.Vector3(0, 0, 150), // Curva 8
        new THREE.Vector3(-50, 0, 100), // Curva 9
        new THREE.Vector3(-100, 0, 50), // Curva 10
        new THREE.Vector3(-150, 0, 0), // Curva 11
        new THREE.Vector3(-200, 0, -50), // Curva 12
        new THREE.Vector3(-150, 0, -100), // Curva 13
        new THREE.Vector3(-100, 0, -150), // Curva 14
        new THREE.Vector3(-50, 0, -200), // Curva 15
        new THREE.Vector3(0, 0, -200) // Fechar o circuito
      ];

      curve = new THREE.CatmullRomCurve3(points, true);

      const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const divisions = 500;

      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];

      for (let i = 0; i < divisions; i++) {
        const t1 = i / divisions;
        const t2 = (i + 1) / divisions;

        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);

        const tangent1 = curve.getTangent(t1);
        const tangent2 = curve.getTangent(t2);

        const normal1 = new THREE.Vector3(-tangent1.z, 0, tangent1.x).normalize();
        const normal2 = new THREE.Vector3(-tangent2.z, 0, tangent2.x).normalize();

        const left1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, -planeWidth / 2);
        const right1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, planeWidth / 2);
        const left2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, -planeWidth / 2);
        const right2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, planeWidth / 2);

        const baseIndex = vertices.length / 3;

        vertices.push(
          left1.x, left1.y, left1.z,
          right1.x, right1.y, right1.z,
          left2.x, left2.y, left2.z,
          right2.x, right2.y, right2.z
        );

        indices.push(
          baseIndex, baseIndex + 1, baseIndex + 2,
          baseIndex + 1, baseIndex + 3, baseIndex + 2
        );
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      const track = new THREE.Mesh(geometry, trackMaterial);

      track.receiveShadow = true;
      track.castShadow = true;
      scene.add(track);

      // Adicionar bordas planas
      addFlatBorders(curve, planeWidth);
    }

    function addFlatBorders(curve, planeWidth) {
      const borderWidth = 2; // Largura da borda
      const borderHeight = 0.3; // Altura da borda (lomba)
      const borderSegments = 500;
      const borderColors = [0xff0000, 0xffffff];

      for (let i = 0; i < borderSegments; i++) {
        const t1 = i / borderSegments;
        const t2 = (i + 1) / borderSegments;

        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);

        const tangent = new THREE.Vector3().subVectors(p2, p1).normalize();
        const direction = new THREE.Vector3().copy(tangent).normalize();
        const up = new THREE.Vector3(0, 1, 0);
        const right = new THREE.Vector3().crossVectors(up, direction).normalize();

        const segmentLength = p1.distanceTo(p2);

        // Criar uma geometria que siga a orientação do segmento
        const createBorder = (offset, color) => {
          const center = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
          const sideOffset = new THREE.Vector3().copy(right).multiplyScalar(offset);
          center.add(sideOffset);

          // Usar BoxGeometry para criar bordas com altura
          const geometry = new THREE.BoxGeometry(
            segmentLength, // Comprimento do segmento
            borderHeight,  // Altura da borda
            borderWidth    // Largura da borda
          );
          const material = new THREE.MeshStandardMaterial({ color });
          const mesh = new THREE.Mesh(geometry, material);

          // Alinhar com a pista
          const quaternion = new THREE.Quaternion();
          quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
          mesh.quaternion.copy(quaternion);

          // Posicionar no mesmo nível da pista
          mesh.position.copy(center);
          mesh.position.y += borderHeight / 2; // Elevar para que a altura fique visível

          scene.add(mesh);
        };

        const color = borderColors[i % 2];
        createBorder(-planeWidth / 2 - borderWidth / 2, color); // Esquerda
        createBorder(planeWidth / 2 + borderWidth / 2, color);  // Direita
      }
    }

    let collisionCount = 0; // Contador de colisões

    function checkCollisionWithBorders(car, curve, planeWidth) {
      if (!curve) {
        console.error("A curva não está definida!");
        return;
      }

      const divisions = 200; // Número de divisões para calcular a posição na pista
      let closestPoint = null;
      let minDist = Infinity;

      // Encontrar o ponto mais próximo na pista
      for (let i = 0; i <= divisions; i++) {
        const t = i / divisions;
        const point = curve.getPoint(t);
        if (!point) {
          console.error(`Ponto inválido na curva para t=${t}`);
          continue;
        }

        const dx = point.x - car.position.x;
        const dz = point.z - car.position.z;
        const distSq = dx * dx + dz * dz;

        if (distSq < minDist) {
          minDist = distSq;
          closestPoint = point;
        }
      }

      if (!closestPoint) {
        console.error("Não foi possível encontrar o ponto mais próximo na curva!");
        return;
      }

      // Calcular a direção perpendicular à pista no ponto mais próximo
      const tangent = curve.getTangentAt(minDist / curve.getLength());
      if (!tangent) {
        console.error("Não foi possível calcular a tangente da curva!");
        return;
      }

      const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

      // Calcular a distância do carro ao centro da pista
      const offset = new THREE.Vector3().subVectors(car.position, closestPoint);
      const distanceToCenter = offset.dot(perpendicular);

      // Verificar se o carro está fora dos limites da pista
      if (Math.abs(distanceToCenter) > planeWidth / 2) {
        collisionCount++; // Incrementar o contador de colisões
        console.log(`Colisão detectada! Total de colisões: ${collisionCount}`);

        // Reposicionar o carro dentro dos limites da pista
        const clampedDistance = Math.sign(distanceToCenter) * (planeWidth / 2 - 0.5); // Ajustar para ficar dentro da pista
        car.position.copy(closestPoint).addScaledVector(perpendicular, clampedDistance);

        // Opcional: Reduzir a velocidade do carro após a colisão
        currentSpeed *= 0.5; // Reduzir a velocidade pela metade
      }
    }

    //Animação do semáforo
    function startRaceCountdown() {
      let index = 0;
      const interval = setInterval(() => {
        if (index < lights.length) {
          lights[index].material.color.set(0x333333); // Apaga a luz
          index++;
        } else {
          clearInterval(interval); // Para o intervalo quando todas as luzes forem apagadas
          console.log('Corrida iniciada!');
        }
      }, 2000); // Apaga uma luz a cada 2 segundos
    }

    //Criação do semáforo
    function createSemaphore() {
      const startPoint = curve.getPoint(0);
      const startTangent = curve.getTangent(0);

      // Calcular a direção perpendicular à pista
      const perpendicular = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();

      // Postes laterais
      const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 32);
      const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

      const pole1 = new THREE.Mesh(poleGeometry, poleMaterial);
      pole1.position.copy(startPoint).addScaledVector(perpendicular, -planeWidth / 2);
      pole1.position.y = 2.5;
      scene.add(pole1);

      const pole2 = new THREE.Mesh(poleGeometry, poleMaterial);
      pole2.position.copy(startPoint).addScaledVector(perpendicular, planeWidth / 2);
      pole2.position.y = 2.5;
      scene.add(pole2);

      // Barra superior
      const barGeometry = new THREE.BoxGeometry(planeWidth, 0.3, 0.3);
      const barMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

      const bar = new THREE.Mesh(barGeometry, barMaterial);
      bar.position.copy(startPoint);
      bar.position.y = 5;
      bar.lookAt(bar.position.clone().add(startTangent));
      scene.add(bar);

      // Semáforos (5 luzes vermelhas)
      const lightGeometry = new THREE.SphereGeometry(0.3, 32, 32);

      const lights = [];
      const lightSpacing = planeWidth / 6;
      for (let i = 0; i < 5; i++) {
        const redLightMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const light = new THREE.Mesh(lightGeometry, redLightMaterial);
        light.position.copy(startPoint);
        light.position.y = 5;
        light.position.addScaledVector(perpendicular, -planeWidth / 2 + lightSpacing * (i + 1));
        scene.add(light);
        lights.push(light);
      }
      return lights;
    }

    function createStartingGrid() {
      const numLines = 10; // Número de linhas de posição
      const lineSpacing = 0.02; // Reduzir ainda mais a distância entre as linhas ao longo do eixo da pista
      const trackWidth = 10; // Largura da pista
      const padding = 1; // Espaçamento das linhas em relação às bordas da pista

      for (let i = 0; i < numLines; i++) {
        // Ajustar o valor inicial de t para começar bem atrás da linha de chegada
        const t = -0.05 - i * lineSpacing; // Começar mais atrás e reduzir o espaçamento

        // Obter o ponto e a tangente da curva para a posição da linha
        const linePoint = curve.getPointAt((1 + t) % 1); // Garantir que o valor de t esteja no intervalo [0, 1]
        const lineTangent = curve.getTangentAt((1 + t) % 1);
        const perpendicular = new THREE.Vector3(-lineTangent.z, 0, lineTangent.x).normalize(); // Direção perpendicular à pista

        // Criar a linha
        const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Material branco
        const lineGeometry = new THREE.PlaneGeometry(2, 0.1); // Geometria para as linhas de posição
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI / 2; // Alinhar com o chão
        line.rotation.z = Math.PI / 2; // Garantir que as linhas fiquem paralelas à pista

        // Alternar entre direita e esquerda
        const direction = i % 2 === 0 ? 1 : -1; // Direita (1) ou esquerda (-1)

        // Calcular a posição da linha com base na borda da pista
        const offset = direction * (trackWidth / 2 - padding); // Ajustar para a borda correspondente
        line.position.copy(linePoint).addScaledVector(perpendicular, offset); // Ajustar no eixo perpendicular
        line.position.y = 0.01; // Elevar ligeiramente para evitar sobreposição com a pista

        scene.add(line);
      }
    }

    function createFinishLine() {
      const finishPoint = curve.getPoint(0); // Ponto próximo ao final da pista
      startLinePosition = finishPoint.clone(); // Armazenar a posição da linha de chegada

      const finishMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Material branco
      const finishGeometry = new THREE.PlaneGeometry(planeWidth, 0.2); // Geometria para a linha de chegada

      const finishLine = new THREE.Mesh(finishGeometry, finishMaterial);
      finishLine.rotation.x = -Math.PI / 2; // Alinhar com o chão
      finishLine.rotation.z = Math.PI / 2; // Garantir que a linha fique paralela à pista
      finishLine.position.copy(finishPoint);
      finishLine.position.y = 0.01; // Elevar ligeiramente para evitar sobreposição com a pista
      scene.add(finishLine);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Atualiza animação do Shrek se necessário
      if (shrekMixer) {
        const delta = clock.getDelta();
        shrekMixer.update(delta);
      }

      if (carModel && curve) {
        // Aceleração progressiva com 'w'
        if (moveUp) {
          currentSpeed += acceleration;
          if (currentSpeed > maxSpeed) currentSpeed = maxSpeed;
        }
        // Frenagem com 's'
        if (moveDown) {
          currentSpeed -= braking;
          if (currentSpeed < 0) currentSpeed = 0;
        }
        // Marcha à ré com 'r'
        if (reverse) {
          currentSpeed -= acceleration;
          if (currentSpeed < -maxSpeed / 8) currentSpeed = -maxSpeed / 8;
        }
        // Reduzir a velocidade gradualmente quando nenhuma tecla é pressionada
        if (!moveUp && !moveDown && !reverse) {
          currentSpeed *= 0.98;
          if (currentSpeed < 0.01 && currentSpeed > -0.01) currentSpeed = 0;
        }
        // Reduzir a velocidade ao virar
        if (moveLeft || moveRight) {
          currentSpeed *= 0.99;
        }
        // Atualizar a posição do carro
        carModel.position.x += Math.sin(carDirection) * currentSpeed;
        carModel.position.z += Math.cos(carDirection) * currentSpeed;
        // Atualizar a rotação do carro
        if (moveLeft) carDirection += turnSpeed;
        if (moveRight) carDirection -= turnSpeed;

        // Ajustar a altura do carro com base na pista
        let closestY = 0;
        let minDist = Infinity;
        const divisions = 200;

        for (let i = 0; i <= divisions; i++) {
          const t = i / divisions;
          const point = curve.getPoint(t);
          const dx = point.x - carModel.position.x;
          const dz = point.z - carModel.position.z;
          const distSq = dx * dx + dz * dz;

          if (distSq < minDist) {
            minDist = distSq;
            closestY = point.y;
          }
        }

        carModel.position.y += (closestY + 0.25 - carModel.position.y) * 0.1;
        carModel.rotation.y = carDirection;

        // Verificar colisão com as bordas da pista
        checkCollisionWithBorders(carModel, curve, planeWidth);

        // Atualizar a posição da câmera para ficar atrás do carro
        const cameraOffset = 10;
        const cameraHeight = 5;

        if (frontView) {
          camera.position.set(
            carModel.position.x,
            carModel.position.y + 1.5,
            carModel.position.z
          );
          camera.rotation.set(0, carDirection, 0);
        } else if (firstPersonView) {
          camera.position.set(
            carModel.position.x + Math.sin(carDirection) * 1.2,
            carModel.position.y + 1.5,
            carModel.position.z + Math.cos(carDirection) * 1.2
          );
          camera.lookAt(
            carModel.position.x + Math.sin(carDirection) * 10,
            carModel.position.y + 1.5,
            carModel.position.z + Math.cos(carDirection) * 10
          );
        } else {
          camera.position.set(
            carModel.position.x - Math.sin(carDirection) * cameraOffset,
            carModel.position.y + cameraHeight,
            carModel.position.z - Math.cos(carDirection) * cameraOffset
          );
          camera.lookAt(carModel.position);
        }

        // Detetar quando o carro completa uma volta
        const startPoint = curve.getPoint(0);
        const distanceToStart = carModel.position.distanceTo(startPoint);

        if (startLinePosition) {
          const distanceToStartLine = carModel.position.distanceTo(startLinePosition);
          if (distanceToStartLine < 5) { // Ajuste o valor 5 conforme necessário para o tamanho da pista
            if (!passedStartLine) {
              passedStartLine = true;
              const currentTime = performance.now();
              if (lapStartTime === 0) {
                lapStartTime = currentTime;
              } else {
                const lapTime = (currentTime - lapStartTime) / 1000;
                lapTimes.push(lapTime);
                lapStartTime = currentTime;
                console.log(`Volta ${lapTimes.length}: ${lapTime.toFixed(2)} segundos`);
              }
            }
          } else {
            passedStartLine = false;
          }
        }

        // Atualizar o display do tempo
        const lapTimesDiv = document.getElementById('lap-times');
        if (lapTimesDiv) {
          lapTimesDiv.innerHTML = `Voltas:<br>`;
          lapTimes.forEach((time, index) => {
            lapTimesDiv.innerHTML += `Volta ${index + 1}: ${time.toFixed(2)}s<br>`;
          });
        } else {
          console.error("Elemento 'lap-times' não encontrado!");
        }
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('resize', onWindowResize);
  </script>
</body>
</html>
