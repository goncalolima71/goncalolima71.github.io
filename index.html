<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8">
  <title>Jogo de F1 3D</title>
  <script>
    const isLocal = window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost";
    const base = document.createElement("base");
    base.href = isLocal ? "/" : "/goncalolima71.github.io/";
    document.head.appendChild(base);
  </script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #start-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #car-custom-btn {
      padding: 12px 28px;
      font-size: 1.2rem;
      border-radius: 8px;
      border: none;
      background: #ffb300;
      color: #222;
      cursor: pointer;
      margin-bottom: 20px;
    }
    #car-custom-btn:hover {
      background: #ffd966;
    }
    #car-selection {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
    }
    .car-option {
      border: 3px solid transparent;
      border-radius: 10px;
      background: #333;
      padding: 10px;
      cursor: pointer;
      transition: border 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .car-option.selected {
      border: 3px solid #007bff;
      background: #222;
    }
    .car-thumb {
      width: 100px;
      height: 60px;
      object-fit: contain;
      margin-bottom: 10px;
      background: #111;
      border-radius: 5px;
    }
    #start-btn {
      padding: 20px 40px;
      font-size: 2rem;
      border: none;
      border-radius: 10px;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      margin-top: 30px;
      transition: background 0.2s;
    }
    #start-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }
    #loading-circle {
      width: 60px;
      height: 60px;
      border: 8px solid #eee;
      border-top: 8px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
      display: none;
    }
    @keyframes spin {
      0% { transform: rotate(0deg);}
      100% { transform: rotate(360deg);}
    }
    #lap-times {
      position: absolute; top: 10px; left: 10px;
      color: rgb(239, 239, 239); font-size: 20px;
      background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px;
      z-index: 1;
      display: none;
    }
    .track-option {
      border: 2px solid transparent;
      border-radius: 8px;
      background: #444;
      color: #fff;
      padding: 10px 24px;
      cursor: pointer;
      font-size: 1.1rem;
      transition: border 0.2s, background 0.2s;
      margin-bottom: 0;
    }
    .track-option.selected {
      border: 2px solid #ffb300;
      background: #222;
      color: #ffb300;
    }
    #popup-message {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0,0,0,0.85);
      color: #fff;
      padding: 14px 32px;
      font-size: 1.5rem;
      border-radius: 10px;
      display: none;
      z-index: 10000;
      font-family: sans-serif;
      font-weight: bold;
      box-shadow: 0 4px 24px #0008;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <!-- Menu inicial -->
  <div id="start-screen">
    <button id="car-custom-btn">Personalizar Carro</button>
    <div id="track-selection" style="display:flex; gap:20px; margin-bottom:20px;">
      <div class="track-option selected" data-track="default">Pista Original</div>
      <div class="track-option" data-track="ocean">Ocean</div>
      <div class= "track-option" data-track="desert">Desert</div>
    </div>
    <div id="loading-circle"></div>
    <button id="start-btn">Start</button>
  </div>
  <!-- Ecrã de personalização do carro (inicialmente escondido) -->
  <div id="car-custom-screen" style="display:none; flex-direction:column; align-items:center; justify-content:center; position:fixed; top:0; left:0; right:0; bottom:0; background:#222; z-index:20;">
    <button id="back-main-menu" style="padding:12px 28px; font-size:1.2rem; border-radius:8px; border:none; background:#007bff; color:#fff; cursor:pointer; margin-bottom:20px;">⬅ Voltar</button>
    <h2 style="color:#fff;">Escolhe o teu carro</h2>
    <div id="cars-list" style="display:flex; gap:40px; flex-wrap:wrap; margin-bottom:40px;"></div>
    <button id="save-car" style="padding:14px 36px; font-size:1.3rem; border-radius:8px; border:none; background:#ffb300; color:#222; cursor:pointer; margin-bottom:20px;">Guardar Seleção</button>
  </div>
  <div id="lap-times">
    Tempo da volta:
  </div>
  <div id="best-lap" style="
  position: absolute;
  top: 10px;
  right: 10px;
  color: #ffe600;
  font-size: 20px;
  background: rgba(0,0,0,0.5);
  padding: 10px 18px;
  border-radius: 5px;
  z-index: 1;
  display: none;
  font-weight: bold;
">
  Melhor volta: --
</div>
  <div id="warning-msg" style="
  display:none;
  position:absolute;
  top:80px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(255,255,255,0.15); /* transparente */
  color:#d6001c; /* vermelho Ferrari */
  padding:8px 22px;
  font-size:1.1rem; /* mais pequeno */
  border-radius:10px;
  z-index:1000;
  font-weight:bold;
  text-align:center;
  opacity:0;
  transition:opacity 0.4s;
  box-shadow:0 2px 12px #0003;
  letter-spacing:0.5px;
">
</div>
  </div>
  <script type="module">
    import * as THREE from 'three';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { TextureLoader } from 'three';

    // --- Personalização do carro ---
    const carConfigs = {
      Ferrari:   { color: 0xd6001c, logo: '/textures/Scuderia-Ferrari-Logo.png' },
      McLaren:   { color: 0xff8700, logo: '/textures/mclaren_logo.png' },
      'Red Bull':{ color: 0x1e2247, logo: '/textures/Red-Bull-Logo-Background-PNG-Image.png' },
      Mercedes:  { color: 0x00e0c6, logo: '/textures/mercedes_logo.png' },
      Williams:  { color: 0x0055a4, logo: '/textures/williams_logo.png' },
      'Aston Martin': { color: 0x00665e, logo: '/textures/aston_martin_logo.png' }
    };
    let selectedCar = localStorage.getItem('selectedCar') || 'Ferrari';

    // Mostrar ecrã de personalização
    document.getElementById('car-custom-btn').onclick = () => {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('car-custom-screen').style.display = 'flex';
      renderCarSelection();
    };
    // Voltar ao menu principal
    document.getElementById('back-main-menu').onclick = () => {
      document.getElementById('car-custom-screen').style.display = 'none';
      document.getElementById('start-screen').style.display = 'flex';
    };

    // Renderizar carros
    function renderCarSelection() {
      const cars = [
        { name: 'Ferrari', color: '#d6001c', logo: '/textures/Scuderia-Ferrari-Logo.png' },
        { name: 'McLaren', color: '#ff8700', logo: '/textures/mclaren_logo.png' },
        { name: 'Red Bull', color: '#1e2247', logo: '/textures/Red-Bull-Logo-Background-PNG-Image.png' },
        { name: 'Mercedes', color: '#00e0c6', logo: '/textures/mercedes_logo.png' },
        { name: 'Williams', color: '#0055a4', logo: '/textures/williams_logo.png' },
        { name: 'Aston Martin', color: '#00665e', logo: '/textures/aston_martin_logo.png' }
      ];
      const carsList = document.getElementById('cars-list');
      carsList.innerHTML = '';
      let current = localStorage.getItem('selectedCar') || 'Ferrari';
      cars.forEach(car => {
        const card = document.createElement('div');
        card.style.background = '#333';
        card.style.borderRadius = '12px';
        card.style.padding = '18px 24px';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.alignItems = 'center';
        card.style.cursor = 'pointer';
        card.style.border = car.name === current ? '3px solid #ffb300' : '3px solid transparent';
        card.style.boxShadow = car.name === current ? '0 0 12px #ffb30088' : '';
        card.innerHTML = `
          <img style="width:60px;height:60px;object-fit:contain;margin-bottom:10px;" src="${car.logo}" alt="${car.name} logo">
          <div style="width:120px;height:60px;border-radius:6px;margin-bottom:10px;background:${car.color};"></div>
          <div style="color:#fff;">${car.name}</div>
        `;
        card.onclick = () => {
          document.querySelectorAll('#cars-list > div').forEach(c => {
            c.style.border = '3px solid transparent';
            c.style.boxShadow = '';
          });
          card.style.border = '3px solid #ffb300';
          card.style.boxShadow = '0 0 12px #ffb30088';
          selectedCar = car.name;
        };
        carsList.appendChild(card);
      });
    }

    // Guardar seleção e voltar ao menu principal
    document.getElementById('save-car').onclick = () => {
      localStorage.setItem('selectedCar', selectedCar);
      document.getElementById('car-custom-screen').style.display = 'none';
      document.getElementById('start-screen').style.display = 'flex';
    };

    // Variáveis globais
    let scene, camera, renderer, carModel;
    let moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
    let currentSpeed = 0;
    const maxSpeed = 1.0;
    const acceleration = 0.02;
    const braking = 0.02;
    const turnSpeed = 0.01;
    let carDirection = 0;
    let curve;
    let reverse = false;
    let planeWidth = 28;
    let planeWidth2 = 50;
    let thirdPersonView = true;
    let frontView = false;
    let firstPersonView = false;
    let lapStartTime = 0;
    let lapTimes = [];
    let collidableObjects = [];
    let currentLap = 0;
    let passedStartLine = false;
    let startLinePosition;
    let lights = [];
    const clock = new THREE.Clock();
    let oceanStartLinePosition = null;
    let oceanStartLinePerp = null;
    let chassisBody;
    let wheelMeshes = [];
    let cornerCutWarnings = 0;
    let warningTimeout = null;
    let dqTimeout = null;
    let wasOffTrack = false;
    const cactusObjects = [];
    let offTrackTimer= 0;
    let lastOffTrackTime = 0;
    let wrongDirectionTimer = 0;
    let lastWrongDirectionTime = 0;
    let isWrongDirection = false;

    // Elementos da UI
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    const loadingCircle = document.getElementById('loading-circle');
    const lapTimesDiv = document.getElementById('lap-times');
    // --- Seleção de pista ---
    const trackOptions = document.querySelectorAll('.track-option');
    let selectedTrack = 'default';
    trackOptions.forEach(option => {
      option.addEventListener('click', () => {
        trackOptions.forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedTrack = option.dataset.track;
      });
    });

    // Estado inicial
    loadingCircle.style.display = 'none';
    startBtn.disabled = false;

    // Ao clicar em Start, carrega o modelo escolhido
    startBtn.addEventListener('click', () => {
      startBtn.disabled = true;
      loadingCircle.style.display = 'block';

      setTimeout(() => {
        loadingCircle.style.display = 'none';
        startScreen.style.display = 'none';
        lapTimesDiv.style.display = 'block';

        if (selectedTrack === 'ocean') {
          initOcean();
        } else if (selectedTrack === 'desert') {
          initDesert();
        } else {
          init();
        }
        animate();
      }, 500); // Simula um pequeno loading
    });

    function isPointNearTrack(x, z, minDist = planeWidth / 2 + 8) {
      if (!curve) return false;
      let closestDist = Infinity;
      const divisions = 500;
      for (let i = 0; i <= divisions; i++) {
        const t = i / divisions;
        const point = curve.getPoint(t);
        const dx = point.x - x;
        const dz = point.z - z;
        const distSq = dx * dx + dz * dz;
        if (distSq < closestDist) closestDist = distSq;
      }
      return Math.sqrt(closestDist) < minDist;
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, 0);

      const oldCanvas = document.querySelector('canvas');
      if (oldCanvas) oldCanvas.remove();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.shadowMap.autoUpdate = true;
      renderer.shadowMap.needsUpdate = true;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x87CEEB);

      // Luz do sol (DirectionalLight) para simular o sol
      const sun = new THREE.DirectionalLight(0xfff7e0, 2.2); // cor amarelada, intensidade forte
      sun.position.set(80, 120, 60); // posição alta e lateral
      sun.castShadow = true;
      sun.shadow.mapSize.width = 4096;
      sun.shadow.mapSize.height = 4096;
      sun.shadow.bias = -0.0005;
      sun.shadow.normalBias = 0.01;
      sun.shadow.radius = 4;
      sun.shadow.camera.near = 10;
      sun.shadow.camera.far = 400;
      sun.shadow.camera.left = -200;
      sun.shadow.camera.right = 200;
      sun.shadow.camera.top = 200;
      sun.shadow.camera.bottom = -200;
      scene.add(sun);

      // Luz direcional extra para iluminar melhor o carro
      const light = new THREE.DirectionalLight(0xffffff, 0.7);
      light.position.set(0, 20, 20);
      light.castShadow = false;
      scene.add(light);

      createTrack();

      // Criar semáforo e guardar as luzes
      lights = createSemaphore();
      createStartingGrid();
      createFinishLine();

      // Atualiza a seleção do carro
      selectedCar = localStorage.getItem('selectedCar') || 'Ferrari';
      const carColor = carConfigs[selectedCar]?.color || 0xd6001c;
      const carLogo = carConfigs[selectedCar]?.logo || '/textures/Scuderia-Ferrari-Logo.png';
      const matRed = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.6, roughness: 0.4 });
      const matBlack = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.5 });
      const matWheel = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.6 });

      const chassisMesh = new THREE.Group();

      const corpo = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 4.4), matRed);
      corpo.castShadow = corpo.receiveShadow = true;
      chassisMesh.add(corpo);

      const cockpitBase = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 1.2), matBlack);
      cockpitBase.position.set(0, 0.25, -0.2);
      cockpitBase.castShadow = cockpitBase.receiveShadow = true;
      chassisMesh.add(cockpitBase);

      const cockpitArco = new THREE.Mesh(
        new THREE.TorusGeometry(0.5, 0.15, 16, 100, Math.PI),
        matBlack
      );
      cockpitArco.rotation.set(Math.PI / 2, 0, 0);
      cockpitArco.position.set(0, 0.55, -0.2);
      chassisMesh.add(cockpitArco);

      const logoTexture = new THREE.TextureLoader().load(carLogo, () => {
        renderer.render(scene, camera);
      });
      logoTexture.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
      const logoMat = new THREE.MeshBasicMaterial({
        map: logoTexture,
        transparent: true,
        depthTest: false,
        side: THREE.DoubleSide
      });
      const logoPlane = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.4), logoMat);
      logoPlane.position.set(0, 0.32, -2.2);
      logoPlane.rotation.x = -Math.PI / 2;
      logoPlane.renderOrder = 10;
      chassisMesh.add(logoPlane);

      const nariz = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.4, 2.3, 12), matRed);
      nariz.rotation.x = Math.PI / 2;
      nariz.position.set(0, 0, 3.4);
      nariz.castShadow = nariz.receiveShadow = true;
      chassisMesh.add(nariz);

      const asaD = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.05, 0.25), matBlack);
      asaD.position.set(0, -0.1, 4.5);
      asaD.castShadow = asaD.receiveShadow = true;
      chassisMesh.add(asaD);

      const asaT = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.05, 0.6), matBlack);
      asaT.position.set(0, 0.3, -2.2);
      asaT.castShadow = asaT.receiveShadow = true;
      chassisMesh.add(asaT);

      for (let x of [-1.0, 1.0]) {
        const suporte = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.35, 0.05), matBlack);
        suporte.position.set(x, 0.175, -2.2);
        suporte.castShadow = suporte.receiveShadow = true;
        chassisMesh.add(suporte);
      }

      const spoiler = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.6, 0.25), matBlack);
      spoiler.position.set(0, 0.3, -2.5);
      chassisMesh.add(spoiler);

      const rodaGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.5, 32);
      const posicoesRodas = [
        [-1.0, -0.25, -1.6], [1.0, -0.25, -1.6],
        [-1.0, -0.25, 1.6], [1.0, -0.25, 1.6]
      ];
      for (let pos of posicoesRodas) {
        const roda = new THREE.Mesh(rodaGeo, matWheel);
        roda.rotation.z = Math.PI / 2;
        roda.position.set(...pos);
        roda.castShadow = roda.receiveShadow = true;
        chassisMesh.add(roda);
        wheelMeshes.push(roda);
      }

      carModel = chassisMesh;
      scene.add(carModel);

      const tStart = 0.99; 
      const startBeforeLine = curve.getPointAt(tStart);
      const forward = curve.getTangentAt(tStart);

      chassisBody.position.set(startBeforeLine.x, startBeforeLine.y + 0.3, startBeforeLine.z);
      chassisBody.velocity.set(0, 0, 0);
      chassisBody.angularVelocity.set(0, 0, 0);

      const up = new CANNON.Vec3(0, 1, 0);
      const q = new CANNON.Quaternion();
      q.setFromVectors(new CANNON.Vec3(0, 0, 1), forward);
      chassisBody.quaternion.copy(q);


      //adicionar relva simples (sem textura)
      const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x3a9c2d });
      const grassGeometry = new THREE.PlaneGeometry(2000, 2000);
      const grass = new THREE.Mesh(grassGeometry, grassMaterial);
      grass.rotation.x = -Math.PI / 2;
      grass.position.y = 0;
      scene.add(grass);

      const grassBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Plane(),
        position: new CANNON.Vec3(0, 0, 0)
      });
      grassBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(grassBody);

      // Função para adicionar árvores maiores e variadas
      function addTree(x, z, type = 0) {
        let trunk, crown;
        if (type === 0) {
          // Árvore redonda grande
          trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.5, 5),
            new THREE.MeshStandardMaterial({ color: 0x8b5a2b })
          );
          trunk.position.set(x, 2.5, z);
          trunk.castShadow = true;
          trunk.receiveShadow = true;

          crown = new THREE.Mesh(
            new THREE.SphereGeometry(2.2, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x267f00 })
          );
          crown.position.set(x, 6, z);
          crown.castShadow = true;
          crown.receiveShadow = true;
        } else {
          // Árvore tipo pinheiro grande
          trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 4),
            new THREE.MeshStandardMaterial({ color: 0x6b4226 })
          );
          trunk.position.set(x, 2, z);
          trunk.castShadow = true;
          trunk.receiveShadow = true;

          crown = new THREE.Mesh(
            new THREE.ConeGeometry(2, 4, 12),
            new THREE.MeshStandardMaterial({ color: 0x1b5e20 })
          );
          crown.position.set(x, 5, z);
          crown.castShadow = true;
          crown.receiveShadow = true;
        }
        scene.add(trunk);
        scene.add(crown);

        // Corpo físico do tronco (cilindro vertical)
        const radius = (type === 0) ? 0.5 : 0.4;
        const height = (type === 0) ? 5 : 4;
        const treeBody = new CANNON.Body({
          mass: 0,
          shape: new CANNON.Cylinder(radius, radius, height, 12),
          position: new CANNON.Vec3(x, height / 2, z)
        });
        world.addBody(treeBody);

        collidableObjects.push(treeBody);
      }

      let treesPlaced = 0;
      let tries = 0;
      const totalTrees = 180;
      while (treesPlaced < totalTrees && tries < totalTrees * 8) {
        tries++;
        const angle = Math.random() * Math.PI * 2;
        const radius = (planeWidth / 2) + 20 + Math.random() * 120; // Mais perto da pista
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        if (!isPointNearTrack(x, z, planeWidth / 2 + 7)) { // margem menor para ficarem mais juntas
          const type = Math.random() > 0.5 ? 1 : 0;
          addTree(x, z, type);
          treesPlaced++;
        }
      }

      startRaceCountdown();
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'a' || key === 'arrowleft') moveLeft = true;
        if (key === 'd' || key === 'arrowright') moveRight = true;
        if (key === 'w' || key === 'arrowup') moveUp = true;
        if (key === 's' || key === 'arrowdown') moveDown = true;
        if (key === 'r') reverse = true;
        if (key === 'p') {
          firstPersonView = !firstPersonView;
          thirdPersonView = !firstPersonView;
        }
        if (key === 'b' && firstPersonView) {
          frontView = true;
        }
      });
      document.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'a' || key === 'arrowleft') moveLeft = false;
        if (key === 'd' || key === 'arrowright') moveRight = false;
        if (key === 'w' || key === 'arrowup') moveUp = false;
        if (key === 's' || key === 'arrowdown') moveDown = false;
        if (key === 'r') reverse = false;
        if (key === 'b') frontView = false;
      });

      window.currentTrackWidth = planeWidth;
    }

    // Função para criar a pista Ocean
    function initOcean() {
      let planeWidth = planeWidth2; // Largura da pista
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x7ec0ee);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x7ec0ee);

      // Sol e luz ambiente
      const sun = new THREE.DirectionalLight(0xfff7e0, 2.2);
      sun.position.set(80, 120, 60);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 4096;
      sun.shadow.mapSize.height = 4096;
      sun.shadow.bias = -0.0005;
      sun.shadow.normalBias = 0.01;
      sun.shadow.radius = 4;
      sun.shadow.camera.near = 10;
      sun.shadow.camera.far = 400;
      sun.shadow.camera.left = -200;
      sun.shadow.camera.right = 200;
      sun.shadow.camera.top = 200;
      sun.shadow.camera.bottom = -200;
      scene.add(sun);
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const light = new THREE.DirectionalLight(0xffffff, 0.7);
      light.position.set(0, 20, 20);
      light.castShadow = false;
      scene.add(light);

      const points = [
        new THREE.Vector3(350, 0, 0),
        new THREE.Vector3(300, 0, 40),
        new THREE.Vector3(250, 0, 80),
        new THREE.Vector3(200, 0, 120),
        new THREE.Vector3(150, 0, 160),
        new THREE.Vector3(100, 0, 200),
        new THREE.Vector3(50, 0, 220),
        new THREE.Vector3(0, 0, 210),
        new THREE.Vector3(-40, 0, 180),
        new THREE.Vector3(-80, 0, 140),
        new THREE.Vector3(-120, 0, 100),
        new THREE.Vector3(-160, 0, 60),
        new THREE.Vector3(-180, 0, 20),
        new THREE.Vector3(-200, 0, -30),
        new THREE.Vector3(-180, 0, -70),
        new THREE.Vector3(-140, 0, -110),
        new THREE.Vector3(-100, 0, -150),
        new THREE.Vector3(-60, 0, -170),
        new THREE.Vector3(-20, 0, -180),
        new THREE.Vector3(20, 0, -200),
        new THREE.Vector3(60, 0, -220),
        new THREE.Vector3(120, 0, -240),
        new THREE.Vector3(200, 0, -260),
        new THREE.Vector3(300, 0, -260),
        new THREE.Vector3(470, 0, -220),
        new THREE.Vector3(470, 0, 0)
      ];
      curve = new THREE.CatmullRomCurve3(points, true);

      // Pista visual
      const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const divisions = 1200;
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];
      for (let i = 0; i < divisions; i++) {
        const t1 = i / divisions;
        const t2 = (i + 1) / divisions;
        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);
        const tangent1 = curve.getTangent(t1);
        const tangent2 = curve.getTangent(t2);
        const normal1 = new THREE.Vector3(-tangent1.z, 0, tangent1.x).normalize();
        const normal2 = new THREE.Vector3(-tangent2.z, 0, tangent2.x).normalize();
        const left1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, -planeWidth / 2);
        const right1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, planeWidth / 2);
        const left2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, -planeWidth / 2);
        const right2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, planeWidth / 2);
        const baseIndex = vertices.length / 3;
        vertices.push(
          left1.x, left1.y+ 0.02, left1.z,
          right1.x, right1.y+ 0.02, right1.z,
          left2.x, left2.y+ 0.02, left2.z,
          right2.x, right2.y+ 0.02, right2.z
        );
        indices.push(
          baseIndex, baseIndex + 1, baseIndex + 2,
          baseIndex + 1, baseIndex + 3, baseIndex + 2
        );
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      const track = new THREE.Mesh(geometry, trackMaterial);
      track.receiveShadow = true;
      track.castShadow = true;
      scene.add(track);

      createOceanPhysicalTrack(curve, planeWidth);
      addOceanTrackLines(curve, planeWidth);
      addOceanGuardRails(curve, planeWidth);
      // Água
      const textureLoader = new THREE.TextureLoader();
      const waterTexture = textureLoader.load('/textures/material_604.png');
      waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
      const seaMaterial = new THREE.MeshStandardMaterial({
        map: waterTexture,
        color: 0x184060,
        transparent: true,
        opacity: 0.85,
        depthWrite: false // <- impede z-fighting
      });
      const seaGeometry = new THREE.PlaneGeometry(6000, 6000);
      const sea = new THREE.Mesh(seaGeometry, seaMaterial);
      sea.rotation.x = -Math.PI / 2;
      sea.position.y = -0.5; 
      sea.receiveShadow = true;
      sea.renderOrder = -1; 
      scene.add(sea);

      // Semáforo e linha de partida (apenas UM semáforo)
      function createOceanSemaphore() {
        const tStart = 0.025;
        const startPoint = curve.getPointAt(tStart);
        const startTangent = curve.getTangentAt(tStart);
        const perpendicular = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();
        // Postes laterais
        const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 32);
        const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const pole1 = new THREE.Mesh(poleGeometry, poleMaterial);
        pole1.position.copy(startPoint).addScaledVector(perpendicular, -planeWidth / 2);
        pole1.position.y = 2.5;
        scene.add(pole1);
        const pole2 = new THREE.Mesh(poleGeometry, poleMaterial);
        pole2.position.copy(startPoint).addScaledVector(perpendicular, planeWidth / 2);
        pole2.position.y = 2.5;
        scene.add(pole2);
        // Barra superior
        const barGeometry = new THREE.BoxGeometry(planeWidth, 0.3, 0.3);
        const barMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const bar = new THREE.Mesh(barGeometry, barMaterial);
        bar.position.copy(startPoint);
        bar.position.y = 5;
        bar.lookAt(bar.position.clone().add(startTangent));
        scene.add(bar);
        // Semáforos (5 luzes vermelhas)
        const lightGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const lightsArr = [];
        const lightSpacing = planeWidth / 6;
        for (let i = 0; i < 5; i++) {
          const redLightMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
          const light = new THREE.Mesh(lightGeometry, redLightMaterial);
          light.position.copy(startPoint);
          light.position.y = 5;
          light.position.addScaledVector(perpendicular, -planeWidth / 2 + lightSpacing * (i + 1));
          scene.add(light);
          lightsArr.push(light);
        }
        return lightsArr;
      }
      function createOceanStartLine() {
        const tStart = 0.025;
        const finishMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const finishGeometry = new THREE.PlaneGeometry(planeWidth, 0.2);
        const finishLine = new THREE.Mesh(finishGeometry, finishMaterial);
        finishLine.rotation.x = -Math.PI / 2;
        const startPoint = curve.getPointAt(tStart);
        const startTangent = curve.getTangentAt(tStart);
        finishLine.rotation.z = Math.atan2(startTangent.x, startTangent.z);
        finishLine.position.copy(startPoint);
        finishLine.position.y = startPoint.y + 0.02;
        scene.add(finishLine);
        oceanStartLinePosition = startPoint.clone();
        oceanStartLinePerp = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();
      }
      lights = createOceanSemaphore();
      createOceanStartLine();

      // --- CRIAÇÃO DO CARRO VISUAL ---
      selectedCar = localStorage.getItem('selectedCar') || 'Ferrari';
      const carColor = carConfigs[selectedCar]?.color || 0xd6001c;
      const carLogo = carConfigs[selectedCar]?.logo || '/textures/Scuderia-Ferrari-Logo.png';
      const matRed = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.6, roughness: 0.4 });
      const matBlack = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.5 });
      const matWheel = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.6 });

      const chassisMesh = new THREE.Group();

      const corpo = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 4.4), matRed);
      corpo.castShadow = corpo.receiveShadow = true;
      chassisMesh.add(corpo);

      const cockpitBase = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 1.2), matBlack);
      cockpitBase.position.set(0, 0.25, -0.2);
      cockpitBase.castShadow = cockpitBase.receiveShadow = true;
      chassisMesh.add(cockpitBase);

      const cockpitArco = new THREE.Mesh(
        new THREE.TorusGeometry(0.5, 0.15, 16, 100, Math.PI),
        matBlack
      );
      cockpitArco.rotation.set(Math.PI / 2, 0, 0);
      cockpitArco.position.set(0, 0.55, -0.2);
      chassisMesh.add(cockpitArco);

      const logoTexture = new THREE.TextureLoader().load(carLogo, () => {
        renderer.render(scene, camera);
      });
      logoTexture.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
      const logoMat = new THREE.MeshBasicMaterial({
        map: logoTexture,
        transparent: true,
        depthTest: false,
        side: THREE.DoubleSide
      });
      const logoPlane = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.4), logoMat);
      logoPlane.position.set(0, 0.32, -2.2);
      logoPlane.rotation.x = -Math.PI / 2;
      logoPlane.renderOrder = 10;
      chassisMesh.add(logoPlane);

      const nariz = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.4, 2.3, 12), matRed);
      nariz.rotation.x = Math.PI / 2;
      nariz.position.set(0, 0, 3.4);
      nariz.castShadow = nariz.receiveShadow = true;
      chassisMesh.add(nariz);

      const asaD = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.05, 0.25), matBlack);
      asaD.position.set(0, -0.1, 4.5);
      asaD.castShadow = asaD.receiveShadow = true;
      chassisMesh.add(asaD);

      const asaT = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.05, 0.6), matBlack);
      asaT.position.set(0, 0.3, -2.2);
      asaT.castShadow = asaT.receiveShadow = true;
      chassisMesh.add(asaT);

      for (let x of [-1.0, 1.0]) {
        const suporte = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.35, 0.05), matBlack);
        suporte.position.set(x, 0.175, -2.2);
        suporte.castShadow = suporte.receiveShadow = true;
        chassisMesh.add(suporte);
      }

      const spoiler = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.6, 0.25), matBlack);
      spoiler.position.set(0, 0.3, -2.5);
      chassisMesh.add(spoiler);

      const rodaGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.5, 32);
      const posicoesRodas = [
        [-1.0, -0.25, -1.6], [1.0, -0.25, -1.6],
        [-1.0, -0.25, 1.6], [1.0, -0.25, 1.6]
      ];
      for (let pos of posicoesRodas) {
        const roda = new THREE.Mesh(rodaGeo, matWheel);
        roda.rotation.z = Math.PI / 2;
        roda.position.set(...pos);
        roda.castShadow = roda.receiveShadow = true;
        chassisMesh.add(roda);
        wheelMeshes.push(roda);
      }

      carModel = chassisMesh;
      scene.add(carModel);

      // Coloca o carro no início da pista
      const tStart = 0.025;
      const startPoint = curve.getPointAt(tStart);
      const startTangent = curve.getTangentAt(tStart);

      carModel.position.copy(startPoint);
      carModel.position.y = startPoint.y + 0.18;

      chassisBody.position.set(startPoint.x, startPoint.y + 0.18, startPoint.z);
      chassisBody.velocity.set(0, 0, 0);
      chassisBody.angularVelocity.set(0, 0, 0);

      const forward = new CANNON.Vec3(startTangent.x, startTangent.y, startTangent.z);
      const q = new CANNON.Quaternion();
      q.setFromVectors(new CANNON.Vec3(0, 0, 1), forward);
      chassisBody.quaternion.copy(q);

      carDirection = Math.atan2(startTangent.x, startTangent.z);
      carModel.rotation.y = carDirection;
      carModel.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      // Listeners (se necessário)
      startRaceCountdown();
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'a' || key === 'arrowleft') moveLeft = true;
        if (key === 'd' || key === 'arrowright') moveRight = true;
        if (key === 'w' || key === 'arrowup') moveUp = true;
        if (key === 's' || key === 'arrowdown') moveDown = true;
        if (key === 'r') reverse = true;
        if (key === 'p') {
          firstPersonView = !firstPersonView;
          thirdPersonView = !firstPersonView;
        }
        if (key === 'b' && firstPersonView) {
          frontView = true;
        }
      });
      document.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'a' || key === 'arrowleft') moveLeft = false;
        if (key === 'd' || key === 'arrowright') moveRight = false;
        if (key === 'w' || key === 'arrowup') moveUp = false;
        if (key === 's' || key === 'arrowdown') moveDown = false;
        if (key === 'r') reverse = false;
        if (key === 'b') frontView = false;
      });

      addOceanBoats(curve, planeWidth);
      window.currentTrackWidth = planeWidth;
    }

    // Função para criar a pista de Desert
    function initDesert() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, 0);

      const oldCanvas = document.querySelector('canvas');
      if (oldCanvas) oldCanvas.remove();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x87CEEB);

      // Plano amarelo claro tipo deserto
      const desertMaterial = new THREE.MeshStandardMaterial({ color: 0xffd34d }); // amarelo claro
      const desertGeometry = new THREE.PlaneGeometry(2000, 2000);
      const desert = new THREE.Mesh(desertGeometry, desertMaterial);
      desert.rotation.x = -Math.PI / 2;
      desert.position.y = 0;
      scene.add(desert);

      const desertBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Plane(),
        position: new CANNON.Vec3(0, 0, 0)
      });
      desertBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(desertBody);

      // Luz do sol (DirectionalLight) para simular o sol
      const sun = new THREE.DirectionalLight(0xfff7e0, 2.2);
      sun.position.set(80, 120, 60); 
      sun.castShadow = true;
      sun.shadow.mapSize.width = 4096;
      sun.shadow.mapSize.height = 4096;
      sun.shadow.bias = -0.0005; 
      sun.shadow.normalBias = 0.01;
      sun.shadow.radius = 4; 
      sun.shadow.camera.near = 10;
      sun.shadow.camera.far = 400;
      sun.shadow.camera.left = -200;
      sun.shadow.camera.right = 200;
      sun.shadow.camera.top = 200;
      sun.shadow.camera.bottom = -200;
      scene.add(sun);

      const light = new THREE.DirectionalLight(0xffffff, 0.7);
      light.position.set(0, 20, 20);
      light.castShadow = false;
      scene.add(light);

      // NOVO: pontos para a pista de Desert (mais longa e variada)
      const desertPoints = [
        new THREE.Vector3(0, 0, -500),      // Reta principal longa
        new THREE.Vector3(120, 0, -480),    // Curva rápida à direita
        new THREE.Vector3(220, 0, -400),    // Reta média
        new THREE.Vector3(260, 0, -300),    // Curva aberta à esquerda
        new THREE.Vector3(250, 0, -180),    // Reta curta
        new THREE.Vector3(180, 0, -100),    // Curva apertada à direita (hairpin)
        new THREE.Vector3(100, 0, -40),     // Reta curta
        new THREE.Vector3(60, 0, 60),       // Curva rápida à esquerda
        new THREE.Vector3(80, 0, 180),      // Reta longa
        new THREE.Vector3(180, 0, 260),     // Curva aberta à direita
        new THREE.Vector3(100, 0, 320),     // Chicane esquerda-direita
        new THREE.Vector3(40, 0, 350),      // Curva apertada à esquerda (hairpin)
        new THREE.Vector3(-40, 0, 340),     // Reta curta
        new THREE.Vector3(-120, 0, 300),    // Curva rápida à esquerda
        new THREE.Vector3(-200, 0, 220),    // Reta média
        new THREE.Vector3(-260, 0, 120),    // Curva aberta à direita
        new THREE.Vector3(-250, 0, 0),      // Reta longa
        new THREE.Vector3(-180, 0, -80),    // Curva rápida à direita
        new THREE.Vector3(-220, 0, -180),   // Reta curta
        new THREE.Vector3(-300, 0, -260),   // Curva apertada à esquerda (hairpin)
        new THREE.Vector3(-320, 0, -380),   // Reta média
        new THREE.Vector3(-200, 0, -480),   // Curva rápida à direita
        new THREE.Vector3(-80, 0, -500),    // Reta longa
      ];
      createTrack(desertPoints);
      createDesertPhysicalTrack(curve, planeWidth);

      // Criar semáforo e guardar as luzes
      lights = createSemaphore();
      createStartingGrid();
      createFinishLine();

      // Atualiza a seleção do carro
      selectedCar = localStorage.getItem('selectedCar') || 'Ferrari';
      const carColor = carConfigs[selectedCar]?.color || 0xd6001c;
      const carLogo = carConfigs[selectedCar]?.logo || '/textures/Scuderia-Ferrari-Logo.png';
      const matRed = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.6, roughness: 0.4 });
      const matBlack = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.5 });
      const matWheel = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.6 });

      const chassisMesh = new THREE.Group();

      const corpo = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 4.4), matRed);
      corpo.castShadow = corpo.receiveShadow = true;
      chassisMesh.add(corpo);

      const cockpitBase = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 1.2), matBlack);
      cockpitBase.position.set(0, 0.25, -0.2);
      cockpitBase.castShadow = cockpitBase.receiveShadow = true;
      chassisMesh.add(cockpitBase);

      const cockpitArco = new THREE.Mesh(
        new THREE.TorusGeometry(0.5, 0.15, 16, 100, Math.PI),
        matBlack
      );
      cockpitArco.rotation.set(Math.PI / 2, 0, 0);
      cockpitArco.position.set(0, 0.55, -0.2);
      chassisMesh.add(cockpitArco);

      const logoTexture = new THREE.TextureLoader().load(carLogo, () => {
        renderer.render(scene, camera);
      });
      logoTexture.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
      const logoMat = new THREE.MeshBasicMaterial({
        map: logoTexture,
        transparent: true,
        depthTest: false,
        side: THREE.DoubleSide
      });
      const logoPlane = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.4), logoMat);
      logoPlane.position.set(0, 0.32, -2.2);
      logoPlane.rotation.x = -Math.PI / 2;
      logoPlane.renderOrder = 10;
      chassisMesh.add(logoPlane);

      const nariz = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.4, 2.3, 12), matRed);
      nariz.rotation.x = Math.PI / 2;
      nariz.position.set(0, 0, 3.4);
      nariz.castShadow = nariz.receiveShadow = true;
      chassisMesh.add(nariz);

      const asaD = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.05, 0.25), matBlack);
      asaD.position.set(0, -0.1, 4.5);
      asaD.castShadow = asaD.receiveShadow = true;
      chassisMesh.add(asaD);

      const asaT = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.05, 0.6), matBlack);
      asaT.position.set(0, 0.3, -2.2);
      asaT.castShadow = asaT.receiveShadow = true;
      chassisMesh.add(asaT);

      for (let x of [-1.0, 1.0]) {
        const suporte = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.35, 0.05), matBlack);
        suporte.position.set(x, 0.175, -2.2);
        suporte.castShadow = suporte.receiveShadow = true;
        chassisMesh.add(suporte);
      }

      const spoiler = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.6, 0.25), matBlack);
      spoiler.position.set(0, 0.3, -2.5);
      chassisMesh.add(spoiler);

      const rodaGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.5, 32);
      const posicoesRodas = [
        [-1.0, -0.25, -1.6], [1.0, -0.25, -1.6],
        [-1.0, -0.25, 1.6], [1.0, -0.25, 1.6]
      ];
      for (let pos of posicoesRodas) {
        const roda = new THREE.Mesh(rodaGeo, matWheel);
        roda.rotation.z = Math.PI / 2;
        roda.position.set(...pos);
        roda.castShadow = roda.receiveShadow = true;
        chassisMesh.add(roda);
        wheelMeshes.push(roda);
      }

      carModel = chassisMesh;
      scene.add(carModel);

      // Coloca o carro no início da pista
      const tStart = -0.01;
      const startPoint = curve.getPointAt(1 + tStart);
      const startTangent = curve.getTangentAt(1 + tStart);

      carModel.position.copy(startPoint);
      carModel.position.y = startPoint.y + 0.3;

      chassisBody.position.set(startPoint.x, startPoint.y + 1.2, startPoint.z);
      chassisBody.velocity.set(0, 0, 0);
      chassisBody.angularVelocity.set(0, 0, 0);

      const forward = new CANNON.Vec3(startTangent.x, startTangent.y, startTangent.z);
      const q = new CANNON.Quaternion();
      q.setFromVectors(new CANNON.Vec3(0, 0, 1), forward);
      chassisBody.quaternion.copy(q);

      carDirection = Math.atan2(startTangent.x, startTangent.z);
      carModel.rotation.y = carDirection;
      carModel.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      // Adiciona cactos no deserto
      let cactiPlaced = 0, cactusTries = 0;
      const totalCacti = 180;
      while (cactiPlaced < totalCacti && cactusTries < totalCacti * 10) {
        cactusTries++;
        const angle = Math.random() * Math.PI * 2;
        const radius = 70 + Math.random() * 600; // Espalhar pelo plano
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        if (typeof isPointNearTrack === "function" && !isPointNearTrack(x, z, planeWidth / 2 + 8)) {
          const type = Math.random() > 0.5 ? 1 : 0;
          addCactus(x, z, type);
          cactiPlaced++;
        }
      }



      startRaceCountdown();
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'a' || key === 'arrowleft') moveLeft = true;
        if (key === 'd' || key === 'arrowright') moveRight = true;
        if (key === 'w' || key === 'arrowup') moveUp = true;
        if (key === 's' || key === 'arrowdown') moveDown = true;
        if (key === 'r') reverse = true;
        if (key === 'p') {
          firstPersonView = !firstPersonView;
          thirdPersonView = !firstPersonView;
        }
        if (key === 'b' && firstPersonView) {
          frontView = true;
        }
      });
      document.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'a' || key === 'arrowleft') moveLeft = false;
        if (key === 'd' || key === 'arrowright') moveRight = false;
        if (key === 'w' || key === 'arrowup') moveUp = false;
        if (key === 's' || key === 'arrowdown') moveDown = false;
        if (key === 'r') reverse = false;
        if (key === 'b') frontView = false;
      });

      window.currentTrackWidth = planeWidth;
    }

    function createTrack(pointsOverride = null) {
      const points = pointsOverride || [
        new THREE.Vector3(0, 0, -200),
        new THREE.Vector3(50, 0, -200),
        new THREE.Vector3(100, 0, -150),
        new THREE.Vector3(150, 0, -100),
        new THREE.Vector3(200, 0, -50),
        new THREE.Vector3(150, 0, 0),
        new THREE.Vector3(100, 0, 50),
        new THREE.Vector3(50, 0, 100),
        new THREE.Vector3(0, 0, 150),
        new THREE.Vector3(-50, 0, 100),
        new THREE.Vector3(-100, 0, 50),
        new THREE.Vector3(-150, 0, 0),
        new THREE.Vector3(-200, 0, -50),
        new THREE.Vector3(-150, 0, -100),
        new THREE.Vector3(-100, 0, -150),
        new THREE.Vector3(-40, 0, -200)
      ];
      curve = new THREE.CatmullRomCurve3(points, true);

      const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide });
      const divisions = 500;

      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];

      for (let i = 0; i < divisions; i++) {
        const t1 = i / divisions;
        const t2 = (i + 1) / divisions;

        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);

        const tangent1 = curve.getTangent(t1);
        const tangent2 = curve.getTangent(t2);

        const normal1 = new THREE.Vector3(-tangent1.z, 0, tangent1.x).normalize();
        const normal2 = new THREE.Vector3(-tangent2.z, 0, tangent2.x).normalize();

        const left1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, -planeWidth / 2);
        const right1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, planeWidth / 2);
        const left2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, -planeWidth / 2);
        const right2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, planeWidth / 2);

        const baseIndex = vertices.length / 3;

        vertices.push(
          left1.x, left1.y + 0.02, left1.z,
          right1.x, right1.y + 0.02, right1.z,
          left2.x, left2.y + 0.02, left2.z,
          right2.x, right2.y + 0.02, right2.z
        );

        indices.push(
          baseIndex, baseIndex + 1, baseIndex + 2,
          baseIndex + 1, baseIndex + 3, baseIndex + 2
        );
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      const track = new THREE.Mesh(geometry, trackMaterial);

      track.receiveShadow = true;
      track.castShadow = true;
      scene.add(track);

      // --- Física da pista (um grande box) ---
      const trackBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(220, 0.1, 220)), // tamanho suficiente para cobrir a pista
        position: new CANNON.Vec3(0, 0, 0)
      });
      world.addBody(trackBody);

      addFlatBorders(curve, planeWidth);
    }

    // Função para adicionar bordas planas
    function addFlatBorders(curve, planeWidth) {
      const borderWidth = 2; // Largura da borda
      const borderHeight = 0.35; // Altura da borda (lomba)
      const borderSegments = 500;
      const borderColors = [0xff0000, 0xffffff];

      for (let i = 0; i < borderSegments; i++) {
        const t1 = i / borderSegments;
        const t2 = (i + 1) / borderSegments;
        const p1 = curve.getPoint(t1);
        const p2 = curve.getPoint(t2);

        // Usa o mesmo método de normais da pista
        const tangent1 = curve.getTangent(t1);
        const tangent2 = curve.getTangent(t2);
        const normal1 = new THREE.Vector3(-tangent1.z, 0, tangent1.x).normalize();
        const normal2 = new THREE.Vector3(-tangent2.z, 0, tangent2.x).normalize();

        // Para cada lado
        for (let side of [-1, 1]) {
          // Posição dos centros das bordas nos extremos do segmento
          const edge1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, side * (planeWidth / 2 + borderWidth / 2));
          const edge2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, side * (planeWidth / 2 + borderWidth / 2));
          const segmentCenter = new THREE.Vector3().addVectors(edge1, edge2).multiplyScalar(0.5);
          const segmentDir = new THREE.Vector3().subVectors(edge2, edge1).normalize();
          const segmentLength = edge1.distanceTo(edge2);

          // Geometria e material
          const geometry = new THREE.BoxGeometry(
            segmentLength, // Comprimento do segmento
            borderHeight,  // Altura da borda
            borderWidth    // Largura da borda
          );
          const color = borderColors[i % 2];
          const material = new THREE.MeshStandardMaterial({ color });
          const mesh = new THREE.Mesh(geometry, material);

          // Alinhar com o segmento da borda
          mesh.position.copy(segmentCenter);
          mesh.position.y += borderHeight / 2 + 0.02;
          mesh.quaternion.setFromUnitVectors(
            new THREE.Vector3(1, 0, 0), segmentDir
          );

          scene.add(mesh);

          // Física (CANNON)
          const shape = new CANNON.Box(new CANNON.Vec3(segmentLength / 2, borderHeight / 2, borderWidth / 2));
          const body = new CANNON.Body({ mass: 0 });
          body.addShape(shape);

          // Orientação física igual à visual
          const cannonQuat = new CANNON.Quaternion();
          cannonQuat.setFromVectors(
            new CANNON.Vec3(1, 0, 0),
            new CANNON.Vec3(segmentDir.x, segmentDir.y, segmentDir.z)
          );
          body.quaternion.copy(cannonQuat);

          body.position.set(segmentCenter.x, mesh.position.y, segmentCenter.z);

          world.addBody(body);
        };
      }
    }

    // Animação do semáforo
    function startRaceCountdown() {
      let index = 0;
      const interval = setInterval(() => {
        if (index < lights.length) {
          lights[index].material.color.set(0x333333); // Apaga a luz
          index++;
        } else {
          clearInterval(interval);
          // Iniciar cronómetro da volta
          lapStartTime = performance.now();
          currentLap = 1;
          passedStartLine = false;
          console.log('Corrida iniciada!');
        }
      }, 2000);
    }

    //Criação do semáforo
    function createSemaphore() {
      const startPoint = curve.getPoint(0);
      // Para garantir alinhamento, usar a tangente da reta inicial
      const startTangent = curve.getTangent(0);
      // Corrigir: usar tangente da reta inicial para garantir alinhamento perfeito
      const perpendicular = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();
      // Postes laterais alinhados exatamente com a largura da pista
      const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 32);
      const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const pole1 = new THREE.Mesh(poleGeometry, poleMaterial);
      pole1.position.copy(startPoint).addScaledVector(perpendicular, -planeWidth / 2);
      pole1.position.y = 2.5;
      scene.add(pole1);
      const pole2 = new THREE.Mesh(poleGeometry, poleMaterial);
      pole2.position.copy(startPoint).addScaledVector(perpendicular, planeWidth / 2);
      pole2.position.y = 2.5;
      scene.add(pole2);
      // Barra superior
      const barGeometry = new THREE.BoxGeometry(planeWidth, 0.3, 0.3);
      const barMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const bar = new THREE.Mesh(barGeometry, barMaterial);
      bar.position.copy(startPoint);
      bar.position.y = 5;
      // Alinhar barra com a tangente da reta inicial
      bar.lookAt(bar.position.clone().add(startTangent));
      scene.add(bar);
      // Semáforos (5 luzes vermelhas)
      const lightGeometry = new THREE.SphereGeometry(0.3, 32, 32);
      const lights = [];
      const lightSpacing = planeWidth / 6;
      for (let i = 0; i < 5; i++) {
        const redLightMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const light = new THREE.Mesh(lightGeometry, redLightMaterial);
        light.position.copy(startPoint);
        light.position.y = 5;
        light.position.addScaledVector(perpendicular, -planeWidth / 2 + lightSpacing * (i + 1));
        scene.add(light);
        lights.push(light);
      }
      return lights;
    }

    function createStartingGrid() {
      const numLines = 10; // Número de linhas de posição
      const lineSpacing = 0.02; // Reduzir ainda mais a distância entre as linhas ao longo do eixo da pista
      const trackWidth = 10; // Largura da pista
      const padding = 1; // Espaçamento das linhas em relação às bordas da pista

      for (let i = 0; i < numLines; i++) {
        // Ajustar o valor inicial de t para começar bem atrás da linha de chegada
        const t = -0.05 - i * lineSpacing; // Começar mais atrás e reduzir o espaçamento

        // Obter o ponto e a tangente da curva para a posição da linha
        const linePoint = curve.getPointAt((1 + t) % 1); // Garantir que o valor de t esteja no intervalo [0, 1]
        const lineTangent = curve.getTangentAt((1 + t) % 1);
        const perpendicular = new THREE.Vector3(-lineTangent.z, 0, lineTangent.x).normalize(); // Direção perpendicular à pista

        // Criar a linha
        const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Material branco
        const lineGeometry = new THREE.PlaneGeometry(2, 0.1); // Geometria para as linhas de posição
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI / 2; // Alinhar com o chão
        line.rotation.z = Math.PI / 2; // Garantir que as linhas fiquem paralelas à pista

        // Alternar entre direita e esquerda
        const direction = i % 2 === 0 ? 1 : -1; // Direita (1) ou esquerda (-1)

        // Calcular a posição da linha com base na borda da pista
        const offset = direction * (trackWidth / 2 - padding); // Ajustar para a borda correspondente
        line.position.copy(linePoint).addScaledVector(perpendicular, offset); // Ajustar no eixo perpendicular
        line.position.y = 0.01; // Elevar ligeiramente para evitar sobreposição com a pista

        scene.add(line);
      }
    }

    function createFinishLine() {
      const finishPoint = curve.getPoint(0); // Ponto próximo ao final da pista
      const finishTangent = curve.getTangent(0); // Tangente naquele ponto
      startLinePosition = finishPoint.clone(); // Armazenar a posição da linha de chegada

      const finishMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Material branco
      const finishGeometry = new THREE.PlaneGeometry(planeWidth, 0.2); // Geometria para a linha de chegada

      const finishLine = new THREE.Mesh(finishGeometry, finishMaterial);
      finishLine.rotation.x = -Math.PI / 2;
      // Alinha a linha de chegada perpendicular à pista
      finishLine.rotation.z = Math.atan2(finishTangent.x, finishTangent.z);
      finishLine.position.copy(finishPoint);
      finishLine.position.y += 0.03; // ligeiramente acima da pista

      scene.add(finishLine);
    }
    // 1. Mundo físico
    const world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);

    // // 2. Chão físico (plano)
    // const groundBody = new CANNON.Body({
    //   mass: 0,
    //   shape: new CANNON.Plane(),
    // });
    // groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    // world.addBody(groundBody);

    // --- CRIAÇÃO DO CHASSIS VISUAL F1 DETALHADO ---
    // Removido o bloco global de criação do chassisMesh daqui!

    // --- CRIAÇÃO DO CHASSIS FÍSICO ---
    const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.25, 2));
    chassisBody = new CANNON.Body({ mass: 150 });
    chassisBody.addShape(chassisShape);

    // Adicionar shape para a asa dianteira (mais estreita e à frente)
    const frontWingShape = new CANNON.Box(new CANNON.Vec3(1.6, 0.05, 0.13)); // largura, altura, profundidade
    const frontWingOffset = new CANNON.Vec3(0, -0.1, 2.25); // x, y, z (ajusta conforme o modelo visual)
    chassisBody.addShape(frontWingShape, frontWingOffset);

    chassisBody.position.set(0, 1, 0);
    world.addBody(chassisBody);

    // 5. Veículo Raycast
    const vehicle = new CANNON.RaycastVehicle({
      chassisBody: chassisBody,
      indexRightAxis: 0,
      indexUpAxis: 1,
      indexForwardAxis: 2
    });
    const wheelOptions = {
      radius: 0.4,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 30,
      suspensionRestLength: 0.3,
     
      frictionSlip: 5,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 100000,
      rollInfluence: 0.01,
      axleLocal: new CANNON.Vec3(-1, 0, 0),
      chassisConnectionPointLocal: new CANNON.Vec3(),
      maxSuspensionTravel: 0.3,
      customSlidingRotationalSpeed: -30,
      useCustomSlidingRotationalSpeed: true
    };
    const wheelPositions = [
      new CANNON.Vec3(-1, 0, 1.5),
      new CANNON.Vec3(1, 0, 1.5),
      new CANNON.Vec3(-1, 0, -1.5),
      new CANNON.Vec3(1, 0, -1.5)
    ];
    wheelPositions.forEach(pos => {
      wheelOptions.chassisConnectionPointLocal.set(pos.x, pos.y, pos.z);
      vehicle.addWheel(wheelOptions);
    });
    vehicle.addToWorld(world);

    // 6. Controlo do carro
    const keys = {};
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    function addOceanBoats(curve, planeWidth, numBoats = 10) {
      let boatsPlaced = 0, tries = 0;
      while (boatsPlaced < numBoats && tries < numBoats * 10) {
        tries++;
        // Distribui barcos em círculo à volta da pista, mas sempre no mar
        const angle = (boatsPlaced / numBoats) * Math.PI * 2 + Math.random() * 0.2;
        const radius = 180 + Math.random() * 500; // Mais longe e maiores
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        // Só coloca barco se estiver longe da pista
        if (typeof isPointNearTrack === "function" && !isPointNearTrack(x, z, planeWidth / 2 + 60)) {
          // Grupo do barco
          const boat = new THREE.Group();

          // Casco (meia elipse)
          const hullGeometry = new THREE.SphereGeometry(12, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.5);
          const hullMaterial = new THREE.MeshStandardMaterial({ color: 0x8d5524, metalness: 0.4, roughness: 0.7 });
          const hull = new THREE.Mesh(hullGeometry, hullMaterial);
          hull.scale.set(2.2, 1, 0.7 + Math.random() * 0.5); // largo e baixo
          hull.position.y = 2.5;
          hull.rotation.x = Math.PI; // <-- Corrige a orientação do casco
          hull.castShadow = hull.receiveShadow = true;
          boat.add(hull);

          // Mastro
          const mastHeight = 22 + Math.random() * 6;
          const mastGeometry = new THREE.CylinderGeometry(0.45, 0.6, mastHeight, 12);
          const mastMaterial = new THREE.MeshStandardMaterial({ color: 0xdeb887, metalness: 0.2, roughness: 0.7 });
          const mast = new THREE.Mesh(mastGeometry, mastMaterial);
          mast.position.set(0, mastHeight / 2 + 2.5, 0);
          mast.castShadow = mast.receiveShadow = true;
          boat.add(mast);

          // Vela principal (triângulo)
          const sailShape = new THREE.Shape();
          sailShape.moveTo(0, 0);
          sailShape.lineTo(0, mastHeight * 0.9);
          sailShape.lineTo(10 + Math.random() * 4, mastHeight * 0.5);
          sailShape.lineTo(0, 0);
          const sailGeometry = new THREE.ShapeGeometry(sailShape);
          const sailMaterial = new THREE.MeshStandardMaterial({ color: 0xfaf3e3, side: THREE.DoubleSide, transparent: true, opacity: 0.92 });
          const sail = new THREE.Mesh(sailGeometry, sailMaterial);
          sail.position.set(0.3, 2.5, 0);
          sail.rotation.y = Math.PI / 2.2 + (Math.random() - 0.5) * 0.2;
          sail.castShadow = sail.receiveShadow = true;
          boat.add(sail);

          // Vela secundária (menor, à frente)
          const sail2Shape = new THREE.Shape();
          sail2Shape.moveTo(0, 0);
          sail2Shape.lineTo(0, mastHeight * 0.5);
          sail2Shape.lineTo(6 + Math.random() * 2, mastHeight * 0.2);
          sail2Shape.lineTo(0, 0);
          const sail2Geometry = new THREE.ShapeGeometry(sail2Shape);
          const sail2Material = new THREE.MeshStandardMaterial({ color: 0xfaf3e3, side: THREE.DoubleSide, transparent: true, opacity: 0.85 });
          const sail2 = new THREE.Mesh(sail2Geometry, sail2Material);
          sail2.position.set(0.3, 2.5, -3.5);
          sail2.rotation.y = Math.PI / 2.1 + (Math.random() - 0.5) * 0.2;
          sail2.castShadow = sail2.receiveShadow = true;
          boat.add(sail2);

          // Orientação aleatória
          boat.rotation.y = angle + Math.PI / 2 + Math.random() * 0.5;

          // Posição no mar
          boat.position.set(x, 0.15, z);

          // Sombra opcional
          boat.castShadow = true;
          boat.receiveShadow = true;

          scene.add(boat);
          boatsPlaced++;
        }
      }
    }

    function updateControls() {
      let maxForce = 1500;
      const steering = 0.5;
      if (selectedTrack === 'desert') {
        // Aumentar a força máxima para desert
        maxForce = 2000;
      }
      // Reset
      for (let i =  0; i < 4; i++) {
        vehicle.setBrake(0, i);
        vehicle.setSteeringValue(0, i);
      }
      // Aplicar força motriz nas rodas da frente (índices 0 e 1)
      if (keys['w']) {
        vehicle.applyEngineForce(-maxForce, 0);
        vehicle.applyEngineForce(-maxForce, 1);
      } else if (keys['s']) {
        vehicle.applyEngineForce(maxForce, 0);
        vehicle.applyEngineForce(maxForce, 1);
      } else {
        vehicle.applyEngineForce(0, 0);
        vehicle.applyEngineForce(0, 1);
      }
      // Direção nas rodas da frente (índices 0 e 1)
      if (keys['a']) {
        vehicle.setSteeringValue(steering, 0);
        vehicle.setSteeringValue(steering, 1);
      } else if (keys['d']) {
        vehicle.setSteeringValue(-steering, 0);
        vehicle.setSteeringValue(-steering, 1);
      }
    }

    // 7. Loop de animação
    function animate() {
      const now = performance.now();
      requestAnimationFrame(animate);
      world.step(1 / 60);
      if (chassisBody.position.y < 0.1) {
        chassisBody.position.y = 0.1;
        chassisBody.velocity.y = 0;
      }

      // Sincronizar chassis visual com o físico
      carModel.position.copy(chassisBody.position);
      carModel.quaternion.copy(chassisBody.quaternion);

      updateControls();

      // Calcular direção do carro a partir da orientação do chassis
      const carDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(carModel.quaternion).normalize();

      if (firstPersonView) {
        // Posição do cockpit (fixa, sem .lerp)
        const cockpitOffset = new THREE.Vector3(0, 1.25, 0.25);
        const cockpitWorld = cockpitOffset.clone().applyQuaternion(carModel.quaternion).add(carModel.position);

        camera.position.copy(cockpitWorld);

        if (frontView) {
          // Olhar para trás (inverter direção)
          const lookBack = new THREE.Vector3(0, 0.45, -4).applyQuaternion(carModel.quaternion).add(carModel.position);
          camera.lookAt(lookBack);
        } else {
          // Olhar para a frente
          const lookFront = new THREE.Vector3(0, 0.45, 4).applyQuaternion(carModel.quaternion).add(carModel.position);
          camera.lookAt(lookFront);
        }
      } else {
        // Terceira pessoa (atrás e acima do carro)
        const cameraOffset = carDirection.clone().multiplyScalar(-10);
        cameraOffset.y = 5;
        const desiredCameraPos = new THREE.Vector3().copy(carModel.position).add(cameraOffset);
        camera.position.lerp(desiredCameraPos, 0.15);
        camera.lookAt(carModel.position);
      }

      // Simular direção realista: rodar rodas dianteiras visualmente (suave e no sentido correto)
      const maxSteerAngle = Math.PI / 8;
      let targetSteer = 0;
      if (keys['a']) targetSteer = maxSteerAngle;
      else if (keys['d']) targetSteer = -maxSteerAngle;

      // Detetar marcha-atrás pelo movimento real do carro no eixo local Z
      let isReverse = false;
      {
        // Obter velocidade do chassis no mundo
        const velocityWorld = chassisBody.velocity;
        // Obter orientação do chassis
        const forwardWorld = new CANNON.Vec3(0, 0, 1);
        chassisBody.vectorToWorldFrame(forwardWorld, forwardWorld);
        // Produto escalar: negativo = marcha-atrás
        const vel = velocityWorld.x * forwardWorld.x + velocityWorld.y * forwardWorld.y + velocityWorld.z * forwardWorld.z;
        isReverse = vel < -0.1;
      }
      if (isReverse) targetSteer *= -1;

      // Interpolação suave do ângulo das rodas dianteiras (as da FRENTE são os índices 2 e 3)
      wheelMeshes[2].rotation.y += (targetSteer - wheelMeshes[2].rotation.y) * 0.09;
      wheelMeshes[3].rotation.y += (targetSteer - wheelMeshes[3].rotation.y) * 0.09;

      // DETETAR SE O CARRO SAIU DA PISTA
      const carPos = carModel.position;

      // Calcular direção do carro e da pista
      const carForward = new THREE.Vector3(0, 0, 1).applyQuaternion(carModel.quaternion).normalize();
      // Encontrar o t da curva mais próximo da posição do carro
      function findClosestTOnCurve(curve, position, divisions = 500) {
        let closestT = 0;
        let minDist = Infinity;
        for (let i = 0; i <= divisions; i++) {
          const t = i / divisions;
          const pt = curve.getPointAt(t);
          const dist = pt.distanceTo(position);
          if (dist < minDist) {
            minDist = dist;
            closestT = t;
          }
        }
        return closestT;
      }

      const t = findClosestTOnCurve(curve, carModel.position, 500);

      const trackForward = curve.getTangentAt(t).normalize();
      const dot = carForward.dot(trackForward);

      // Se o ângulo for muito negativo, está em sentido contrário
      if (dot < -0.6) { // Ajusta o threshold conforme necessário
        showWarning("Wrong direction");
        if (!isWrongDirection) {
          lastWrongDirectionTime = now;
          wrongDirectionTimer = 0;
        } else {
          wrongDirectionTimer += (now - lastWrongDirectionTime);
          if (wrongDirectionTimer >= 5000) { // 5 segundos
            // Reposiciona o carro no início da pista
            const tStart = 0.001; // Pequeno valor para ficar antes da linha
            const start = curve.getPointAt(tStart);
            const tangent = curve.getTangentAt(tStart);
            carModel.position.copy(start);
            carModel.position.y += 0.3;
            chassisBody.position.set(start.x, start.y + 1.2, start.z);
            chassisBody.velocity.set(0, 0, 0);
            chassisBody.angularVelocity.set(0, 0, 0);
            const forward = new CANNON.Vec3(tangent.x, tangent.y, tangent.z);
            const q = new CANNON.Quaternion();
            q.setFromVectors(new CANNON.Vec3(0, 0, 1), forward);
            chassisBody.quaternion.copy(q);
            carModel.rotation.y = Math.atan2(tangent.x, tangent.z);
            wrongDirectionTimer = 0;
          }
          lastWrongDirectionTime = now;
        }
        isWrongDirection = true;
      } else {
        isWrongDirection = false;
        wrongDirectionTimer = 0;
      }

      // Detetar se está fora da pista (na relva)
      const borderWidth = 2; // Largura da borda
      const isOffTrack = typeof isPointNearTrack === "function" &&
                        !isPointNearTrack(carPos.x, carPos.z, (window.currentTrackWidth || planeWidth) / 2 + borderWidth);

      if (isOffTrack) {
        // Mostra warning visual sempre que estiver fora da pista
        showWarning(cornerCutWarnings >= 4 ? "DQ: Disqualified" : "Warning: corner cutting");

        // Timer de desqualificação por tempo fora da pista
        if (!wasOffTrack) {
          lastOffTrackTime = now;
          offTrackTimer = 0;
        } else {
          offTrackTimer += (now - lastOffTrackTime);
          lastOffTrackTime = now;
          if (offTrackTimer >= 10000 && cornerCutWarnings < 4) { // 10 segundos
            cornerCutWarnings = 4;
            showWarning("DQ: Disqualified");
            document.getElementById('lap-times').innerText += `\n❌DQ: Disqualified`;
            if (!dqTimeout) {
              dqTimeout = setTimeout(() => {
                document.getElementById('start-screen').style.display = 'flex';
                document.getElementById('lap-times').style.display = 'none';
                location.reload();
              }, 4000);
            }
          }
        }
        
        if (!wasOffTrack && cornerCutWarnings < 4) {
          cornerCutWarnings++;
          // Atualiza painel de tempos com warnings
          let lapsText = lapTimes.map((t, i) => `Volta ${i + 1}: ${t.toFixed(2)}s`).join('\n');
          lapsText += `\nVolta atual: ${currentLap}`;
          lapsText += `\nWarnings: ${cornerCutWarnings}`;
          if (cornerCutWarnings >= 4) {
            lapsText += `\n❌DQ: Disqualified`;
          } else {
            lapsText += `\n⚠️Warning: corner cutting`;
          }
          document.getElementById('lap-times').innerText = lapsText;

          // Se DQ, recarrega após uns segundos
          if (cornerCutWarnings >= 4 && !dqTimeout) {
            dqTimeout = setTimeout(() => {
              document.getElementById('start-screen').style.display = 'flex';
              document.getElementById('lap-times').style.display = 'none';
              location.reload();
            }, 4000);
          }
        }
        wasOffTrack = true;
      } else if (!isWrongDirection) {
        // Só esconde o warning se não estiver em sentido contrário
        const warningDiv = document.getElementById('warning-msg');
        warningDiv.style.opacity = '0';
        setTimeout(() => {
          warningDiv.style.display = 'none';
        }, 600);
        offTrackTimer = 0; // Reseta o timer quando volta à pista
        wasOffTrack = false;
      }

      // // Detetar se está fora da pista (na relva)
      // const isOffTrack = typeof isPointNearTrack === "function" &&
      //                    !isPointNearTrack(carPos.x, carPos.z, planeWidth / 2);

      // if (isOffTrack) {
      //   if (!wasOffTrack && cornerCutWarnings < 3) {
      //     cornerCutWarnings++;
      //     showWarning("warning: corner cutting");
      //     showPopupMessage(`⚠️ Warning ${cornerCutWarnings}: Corner Cutting`);
      //     if (cornerCutWarnings >= 3 && !dqTimeout) {
      //       dqTimeout = setTimeout(() => {
      //         showWarning("DQ: Disqualified");
      //         showPopupMessage('❌ DQ: Disqualified');
      //         setTimeout(() => {
      //           document.getElementById('start-screen').style.display = 'flex';
      //           document.getElementById('lap-times').style.display = 'none';
      //           location.reload();
      //         }, 5000);
      //       }, 1200);
      //     }
      //   }
      //   wasOffTrack = true;
      // } else {
      //   wasOffTrack = false;
      // }

        // Detetar passagem pela linha de chegada
        if (selectedTrack === 'ocean' && oceanStartLinePosition && oceanStartLinePerp) {
        // Calcula a distância perpendicular do carro ao plano da linha de chegada
        const carToLine = new THREE.Vector3().subVectors(carPos, oceanStartLinePosition);
        const perpDist = carToLine.dot(oceanStartLinePerp);
        const lateralDist = Math.abs(carToLine.dot(new THREE.Vector3(oceanStartLinePerp.z, 0, -oceanStartLinePerp.x))); // ao longo da linha

        if (Math.abs(perpDist) < 2.5 && lateralDist < planeWidth2 / 2) { // 2.5 é a "espessura" da linha, ajusta se quiseres
          if (!passedStartLine) {
            passedStartLine = true;
            if (lapStartTime !== null) {
              const now = performance.now();
              const lapTime = (now - lapStartTime) / 1000;
              lapStartTime = now;
              currentLap++;
              if (currentLap > 1) {
                lapTimes.push(lapTime);
              }
              const lapsText = lapTimes.map((t, i) => `Volta ${i + 1}: ${t.toFixed(2)}s`).join('\n');
              document.getElementById('lap-times').innerText = lapsText + `\nVolta atual: ${currentLap}`;

              // NOVO: Atualizar melhor volta
              const bestLapDiv = document.getElementById('best-lap');
              if (lapTimes.length > 0) {
                const best = Math.min(...lapTimes);
                bestLapDiv.innerText = `Melhor volta: ${best.toFixed(2)}s`;
                bestLapDiv.style.display = 'block';
              } else {
                bestLapDiv.innerText = 'Melhor volta: --';
                bestLapDiv.style.display = 'none';
              }
            }
          }
        } else {
          passedStartLine = false;
        }
      } else {
        // Mantém o método antigo para as outras pistas
        const startLine = startLinePosition || new THREE.Vector3(0, 0, -200);
        const distToStart = carPos.distanceTo(startLine);

        if (distToStart < 5) {
          if (!passedStartLine) {
            passedStartLine = true;
            if (lapStartTime !== null) {
              const now = performance.now();
              const lapTime = (now - lapStartTime) / 1000;
              lapStartTime = now;
              currentLap++;
              if (currentLap > 1) {
                lapTimes.push(lapTime);
              }
              const lapsText = lapTimes.map((t, i) => `Volta ${i + 1}: ${t.toFixed(2)}s`).join('\n');
              document.getElementById('lap-times').innerText = lapsText + `\nVolta atual: ${currentLap}`;

              // Atualizar melhor volta também para pistas não-Mónaco
              const bestLapDiv = document.getElementById('best-lap');
              if (lapTimes.length > 0) {
                const best = Math.min(...lapTimes);
                bestLapDiv.innerText = `Melhor volta: ${best.toFixed(2)}s`;
                bestLapDiv.style.display = 'block';
              } else {
                bestLapDiv.innerText = 'Melhor volta: --';
                bestLapDiv.style.display = 'none';
              }
            }
          }
        } else {
          passedStartLine = false;
        }
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      if (!camera || !renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Função para criar a pista de Mónaco (física)
    function createOceanPhysicalTrack(curve, planeWidth) {
      const divisions = 1800; // Muito mais segmentos!
      const overlap = 2.0;   // Mais sobreposição = menos gaps
      for (let i = 0; i < divisions; i++) {
        const t1 = i / divisions;
        const t2 = (i + 1) / divisions;
        const p1 = curve.getPointAt(t1);
        const p2 = curve.getPointAt(t2);

        const segmentDir = new CANNON.Vec3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z).unit();
        const length = p1.distanceTo(p2) + overlap;

        const center = new CANNON.Vec3(
          (p1.x + p2.x) / 2 + segmentDir.x * (overlap / 2),
          (p1.y + p2.y) / 2 + segmentDir.y * (overlap / 2),
          (p1.z + p2.z) / 2 + segmentDir.z * (overlap / 2)
        );
        center.y = 0.02; // metade da altura do box

        const boxShape = new CANNON.Box(
          new CANNON.Vec3(planeWidth / 2, 0.3, length / 2)
        );
        const boxBody = new CANNON.Body({ mass: 0 });
        boxBody.addShape(boxShape);

        const defaultDir = new CANNON.Vec3(0, 0, 1);
        const q = new CANNON.Quaternion();
        q.setFromVectors(defaultDir, segmentDir);
        boxBody.quaternion.copy(q);

        boxBody.position.copy(center);

        world.addBody(boxBody);
      }
    }

    // function adddesertStands() {
    //   // Posição de referência: pontos da pista
    //   const standPositions = [
    //     { t: 0.05, side: 1 },   // início da reta principal, lado direito
    //     { t: 0.25, side: -1 },  // curva 1, lado esquerdo
    //     { t: 0.65, side: 1 },   // zona oposta, lado direito
    //   ];

    //   for (const { t, side } of standPositions) {
    //     const point = curve.getPointAt(t);
    //     const tangent = curve.getTangentAt(t);
    //     const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
    //     const offset = planeWidth / 2 + 18;

    //     // Parâmetros da bancada
    //     const numDegraus = 6;
    //     const degrauAltura = 0.7;
    //     const degrauProfundidade = 2.5;
    //     const largura = 18;
    //     const corDegrau = 0xcccccc;

    //     // O comprimento do degrau maior (base)
    //     const degrauBaseComprimento = degrauProfundidade * numDegraus;

    //     for (let i = 0; i < numDegraus; i++) {
    //     const degrauComprimento = degrauProfundidade * (numDegraus - i);
    //     const degrauGeo = new THREE.BoxGeometry(largura, degrauAltura, degrauComprimento);
    //     const degrauMat = new THREE.MeshStandardMaterial({ color: corDegrau });
    //     const degrau = new THREE.Mesh(degrauGeo, degrauMat);

    //     // Alinhar a frente dos degraus todos no mesmo sítio (junto à pista)
    //     degrau.position.copy(point)
    //       .addScaledVector(normal, side * offset)
    //       .addScaledVector(normal, -degrauComprimento/ 2 + degrauProfundidade / 2);
    //     degrau.position.y = degrauAltura / 2 + i * degrauAltura;
    //     degrau.castShadow = true;
    //     degrau.receiveShadow = true;
    //     scene.add(degrau);
    //   }

    //     // Adicionar guarda-corpos
    //     const railHeight = 1.5; // Altura do guarda-corpo
    //     const railGeo = new THREE.BoxGeometry(largura, railHeight, 0.2);
    //     const railMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
    //     const rail = new THREE.Mesh(railGeo, railMat);
    //     rail.position.copy(point).addScaledVector(normal, side * offset);
    //     rail.position.y = railHeight / 2 + numDegraus * degrauAltura;
    //     scene.add(rail);

    //     // Física do guarda-corpo
    //     const railShape = new CANNON.Box(new CANNON.Vec3(largura / 2, railHeight / 2, 0.1));
    //     const railBody = new CANNON.Body({ mass: 0 });
    //     railBody.addShape(railShape);
    //     railBody.position.set(rail.position.x, rail.position.y, rail.position.z);
    //     world.addBody(railBody);  
    //   }
    // }

    function addCactus(x, z, type = 0) {
      // Verde escuro
      const cactusGreen = [0x245c2a, 0x1b3d1e, 0x2e7031, 0x295c2a];
      const color = cactusGreen[Math.floor(Math.random() * cactusGreen.length)];

      // Criar grupo para o cato
      const cactus = new THREE.Group();

      // Tronco principal (mais grosso)
      const trunkHeight = 2.5 + Math.random() * 4.5;
      const trunkRadius = 0.35 + Math.random() * 0.22;
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(trunkRadius, trunkRadius * (1.1 + Math.random()*0.2), trunkHeight, 14),
        new THREE.MeshStandardMaterial({ color, roughness: 0.7, metalness: 0.1 })
      );
      trunk.position.set(0, trunkHeight / 2, 0);
      trunk.castShadow = trunk.receiveShadow = true;
      cactus.add(trunk);

      // Número de braços (1 a 3)
      const numArms = 1 + Math.floor(Math.random() * 3);

      for (let i = 0; i < numArms; i++) {
        // Altura do braço no tronco (entre 40% e 80% do tronco)
        const armY = trunkHeight * (0.4 + Math.random() * 0.4);

        // Lado do braço: -1 (esquerda) ou 1 (direita)
        const side = (i % 2 === 0 ? 1 : -1) * (Math.random() > 0.5 ? 1 : -1);

        // Comprimento do braço horizontal e vertical
        const armLength = 0.7 + Math.random() * 0.7;
        const armRadius = trunkRadius * (0.6 + Math.random() * 0.3);
        const upLength = 0.8 + Math.random() * 1.2;

        // Braço horizontal (base)
        const armBase = new THREE.Mesh(
          new THREE.CylinderGeometry(armRadius, armRadius, armLength, 10),
          new THREE.MeshStandardMaterial({ color, roughness: 0.7, metalness: 0.1 })
        );
        armBase.position.set(side * (trunkRadius + armLength / 2), armY, 0);
        armBase.rotation.z = Math.PI / 2;
        armBase.castShadow = armBase.receiveShadow = true;
        cactus.add(armBase);

        // Braço vertical (ponta)
        const armUp = new THREE.Mesh(
          new THREE.CylinderGeometry(armRadius * 0.85, armRadius * 0.7, upLength, 10),
          new THREE.MeshStandardMaterial({ color, roughness: 0.7, metalness: 0.1 })
        );
        armUp.position.set(side * (trunkRadius + armLength), armY + upLength / 2, 0);
        armUp.castShadow = armUp.receiveShadow = true;
        cactus.add(armUp);
      }

      // Posicionar o grupo do cato
      cactus.position.set(x, 0, z);
      scene.add(cactus);

      // // Corpo físico do cato (apenas o tronco, para simplificar)
      // const cactusBody = new CANNON.Body({
      //   mass: 0,
      //   shape: new CANNON.Cylinder(trunkRadius, trunkRadius, trunkHeight, 12),
      //   position: new CANNON.Vec3(x, trunkHeight / 2, z)
      // });
      // world.addBody(cactusBody);

      // Guardar para sincronizar (caso o cato seja dinâmico, mas para objetos estáticos não é necessário atualizar no loop)
      cactusObjects.push({ mesh: cactus});

      return cactus;
    }

    function createDesertPhysicalTrack(curve, planeWidth) {
      const divisions = 900;
      const overlap = 3.5;
      for (let i = 0; i < divisions; i++) {
        const t1 = i / divisions;
        const t2 = (i + 1) / divisions;
        const p1 = curve.getPointAt(t1);
        const p2 = curve.getPointAt(t2);

        const segmentDir = new CANNON.Vec3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z).unit();
        const length = p1.distanceTo(p2) + overlap;

        const center = new CANNON.Vec3(
          (p1.x + p2.x) / 2 + segmentDir.x * (overlap / 2),
          (p1.y + p2.y) / 2 + segmentDir.y * (overlap / 2),
          (p1.z + p2.z) / 2 + segmentDir.z * (overlap / 2)
        );
      center.y += 0.18;

        const boxShape = new CANNON.Box(
          new CANNON.Vec3(planeWidth / 2, 0.18, length / 2)
        );
        const boxBody = new CANNON.Body({ mass: 0 });
        boxBody.addShape(boxShape);

        const defaultDir = new CANNON.Vec3(0, 0, 1);
        const q = new CANNON.Quaternion();
        q.setFromVectors(defaultDir, segmentDir);
        boxBody.quaternion.copy(q);

        boxBody.position.copy(center);

        world.addBody(boxBody);
      }
    }


    // Função para mostrar o warning na UI e na consola
    function showWarning(msg) {
      const warningDiv = document.getElementById('warning-msg');
      warningDiv.innerText = msg;
      warningDiv.style.display = 'block'; // <-- ESSENCIAL!
      // Força o reflow para garantir que a transição é aplicada
      void warningDiv.offsetWidth;
      warningDiv.style.opacity = '1';
      warningDiv.style.transition = 'opacity 0.4s';
      console.warn(msg);
      // NÃO ESCONDER AUTOMATICAMENTE!
    }

    function showPopupMessage(msg, duration = 2200) {
      const popup = document.getElementById('popup-message');
      popup.innerText = msg;
      popup.style.display = 'block';
      popup.style.opacity = '1';
      popup.style.transition = 'opacity 0.4s';

      clearTimeout(window.popupTimeout);
      window.popupTimeout = setTimeout(() => {
        popup.style.opacity = '0';
        setTimeout(() => {
          popup.style.display = 'none';
        }, 500);
      }, duration);
    }

    function addOceanTrackLines(curve, planeWidth) {
      const numDashes = 80;
      const dashLength = 0.9;
      for (let i = 0; i < numDashes; i++) {
        const t = i / numDashes;
        const point = curve.getPointAt(t);
        const tangent = curve.getTangentAt(t);

        // Material só visível de cima
        const lineMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          depthWrite: true,
          transparent: false,
          opacity: 1,
          side: THREE.FrontSide // <-- só visível de cima
        });
        const lineGeometry = new THREE.PlaneGeometry(dashLength, 0.18);
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI / 2;
        line.position.copy(point);
        line.position.y += 0.25; // ainda mais acima da pista

        // Alinhar a linha com a pista
        line.rotation.z = Math.atan2(tangent.x, tangent.z);

        // Só adicionar metade dos traços para criar efeito tracejado
        if (i % 2 === 0) scene.add(line);
      }
    }

    function addOceanGuardRails(curve, planeWidth) {
      const borderSegments = 80;
      const railHeight = 3.2;
      const railWidth = 0.4;
      const railOffset = planeWidth / 2 + railWidth / 2 + 0.01;

      for (let i = 0; i < borderSegments; i++) {
        const t1 = i / borderSegments;
        const t2 = (i + 1) / borderSegments;
        const p1 = curve.getPointAt(t1);
        const p2 = curve.getPointAt(t2);

        const tangent1 = curve.getTangentAt(t1);
        const tangent2 = curve.getTangentAt(t2);
        const normal1 = new THREE.Vector3(-tangent1.z, 0, tangent1.x).normalize();
        const normal2 = new THREE.Vector3(-tangent2.z, 0, tangent2.x).normalize();

        for (let side of [-1, 1]) {
          // Calcula os extremos da barreira para cada lado
          const edge1 = new THREE.Vector3().copy(p1).addScaledVector(normal1, side * railOffset);
          const edge2 = new THREE.Vector3().copy(p2).addScaledVector(normal2, side * railOffset);

          // Centro e direção da barreira
          const center = new THREE.Vector3().addVectors(edge1, edge2).multiplyScalar(0.5);
          center.y = (p1.y + p2.y) / 2 + railHeight / 2;
          const segmentDir = new THREE.Vector3().subVectors(edge2, edge1).normalize();
          const segmentLength = edge1.distanceTo(edge2);

          // Visual
          const geometry = new THREE.BoxGeometry(segmentLength, railHeight, railWidth);
          const material = new THREE.MeshStandardMaterial({
            color: 0xb0b8c1,
            metalness: 0.8,
            roughness: 0.3
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.copy(center);
          // Alinha o comprimento do box com a direção do segmento
          mesh.quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), segmentDir);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);

          // Física
          const railShape = new CANNON.Box(new CANNON.Vec3(segmentLength / 2, railHeight / 2, railWidth / 2));
          const railBody = new CANNON.Body({ mass: 0 });
          railBody.addShape(railShape);
          railBody.position.set(center.x, center.y, center.z);
          // Orientação física igual à visual
          const cannonQuat = new CANNON.Quaternion();
          cannonQuat.setFromVectors(
            new CANNON.Vec3(1, 0, 0),
            new CANNON.Vec3(segmentDir.x, segmentDir.y, segmentDir.z)
          );
          railBody.quaternion.copy(cannonQuat);
          world.addBody(railBody);
        }
      }
    }
    
    function createGravelOffTrack() {
      const gravelTexture = new THREE.TextureLoader().load('/textures/Gravel041.png');
      gravelTexture.wrapS = gravelTexture.wrapT = THREE.RepeatWrapping;
      gravelTexture.repeat.set(50, 50);

      const gravelMaterial = new THREE.MeshStandardMaterial({ map: gravelTexture });
      const gravel = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), gravelMaterial);
      gravel.rotation.x = -Math.PI / 2;
      gravel.position.y = -0.02;
      scene.add(gravel);

      const gravelBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Plane(),
        position: new CANNON.Vec3(0, 0, 0)
      });
      gravelBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(gravelBody);
    }


  </script>
</body>
</html>